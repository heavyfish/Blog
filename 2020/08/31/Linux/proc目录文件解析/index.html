<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
    
    


    <!-- meta -->


<title>no title | 速查笔记</title>





    <!-- OpenGraph -->
 
    <meta name="description" content="参考链接proc man page [&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F; 下网络参数的理解以及sysctl命令修改内核参数](&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F; 下网络参数的理解以及sysctl命令修改内核参数)（此文档中的文件未在本文记录，作为补充） THE PROC FILE SYSTEM（红帽官网） 另，通过 yum install kernel-doc.noarch，其中有关于各文">
<meta property="og:type" content="article">
<meta property="og:title" content="速查笔记">
<meta property="og:url" content="https://heavyfish.github.io/2020/08/31/Linux/proc%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="速查笔记">
<meta property="og:description" content="参考链接proc man page [&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F; 下网络参数的理解以及sysctl命令修改内核参数](&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F; 下网络参数的理解以及sysctl命令修改内核参数)（此文档中的文件未在本文记录，作为补充） THE PROC FILE SYSTEM（红帽官网） 另，通过 yum install kernel-doc.noarch，其中有关于各文">
<meta property="og:locale">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831175948363.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831180258782.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831180952445.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831181721095.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831184033694.png">
<meta property="og:image" content="file:////Users/shenshawn/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image001.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831221336055.png">
<meta property="og:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831224528887.png">
<meta property="article:published_time" content="2020-08-31T02:56:00.730Z">
<meta property="article:modified_time" content="2020-09-01T12:49:38.267Z">
<meta property="article:author" content="Shenxr">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://heavyfish.github.io/Users/shenshawn/Library/Application%20Support/typora-user-images/image-20200831175948363.png">


    
<link rel="stylesheet" href="/heavyfish.github.io/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/heavyfish.github.io/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/heavyfish.github.io/" class="button">
            <span class="logo__text">Demo</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/heavyfish.github.io/" class="navbar-menu button">首页</a>
                
                    <a href="/heavyfish.github.io/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/heavyfish.github.io/categories/" class="navbar-menu button">分类</a>
                
                    <a href="/heavyfish.github.io/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/heavyfish.github.io/friends/" class="navbar-menu button">友链</a>
                
                    <a href="/heavyfish.github.io/page/" class="navbar-menu button">Page</a>
                
            </div>
        
        
        

        
        

        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/heavyfish.github.io/" class="dropdown-menu button">首页</a>
                
                    <a href="/heavyfish.github.io/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/heavyfish.github.io/categories/" class="dropdown-menu button">分类</a>
                
                    <a href="/heavyfish.github.io/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/heavyfish.github.io/friends/" class="dropdown-menu button">友链</a>
                
                    <a href="/heavyfish.github.io/page/" class="dropdown-menu button">Page</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        no title
    </h1>
    <div class="post-title__meta">
        <a href="/heavyfish.github.io/archives/2020/08/" class="post-meta__date button">2020-08-31</a>
        
 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/proc.5.html">proc man page</a></p>
<p>[/proc/sys/net/ipv4/ 下网络参数的理解以及sysctl命令修改内核参数](/proc/sys/net/ipv4/ 下网络参数的理解以及sysctl命令修改内核参数)（此文档中的文件未在本文记录，作为补充）</p>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-proc">THE PROC FILE SYSTEM</a>（红帽官网）</p>
<p>另，通过 <code>yum install kernel-doc.noarch</code>，其中有关于各文件参数的解析</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>proc —— 进程信息伪文件系统</p>
<p>proc文件系统是伪文件系统，可提供与内核数据结构的接口。通常挂载在/proc。通常，它是由系统自动安装的，但是也可以使用以下命令手动挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc proc &#x2F;proc</span><br></pre></td></tr></table></figure>
<p>proc文件系统中的大多数文件都是只读的，但是有些文件是可写的，允许更改内核变量。</p>
<p>操作系统屏蔽了用户直接访问系统内核的可能性。但是Linux提供了LKM机制可以使我们在内核空间工作，在LKM机制中一个重要的组成部分就是proc伪文件系统，它为用户提供了动态操作Linux内核信息的接口，是除系统调用之外另一个重要的Linux内核空间与用户空间交换数据的途径。</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>在/ proc下，有以下常规文件组和子目录：</p>
<h2 id="proc-pid-子目录"><a href="#proc-pid-子目录" class="headerlink" title="/proc/[pid] 子目录"></a>/proc/[pid] 子目录</h2><p>这些子目录中的每个子目录都包含文件和子目录，这些文件和子目录公开了具有相应进程ID的有关该进程的信息。</p>
<p>在每个/ proc / [pid]目录下，一个任务子目录包含task / [tid]形式的子目录，这些子目录包含有关进程中每个线程的相应信息，其中tid是该进程的内核线程ID。</p>
<p>当使用getdents（2）遍历/ proc时，/ proc / [pid]子目录是可见的（因此当使用ls（1）查看/ proc的内容时，它们是可见的）。</p>
<h2 id="proc-tid-子目录"><a href="#proc-tid-子目录" class="headerlink" title="/proc/[tid] 子目录"></a>/proc/[tid] 子目录</h2><p>这些子目录中的每个子目录都包含文件和子目录，这些文件和子目录公开了具有相应线程ID的线程信息。 这些目录的内容与相应的/ proc / [pid] / task / [tid]目录相同。</p>
<p>当使用getdents（2）遍历/ proc时，/ proc / [tid]子目录不可见（因此，当使用ls（1）查看/ proc的内容时，/ proc / [tid]子目录也不可见）。</p>
<h2 id="proc-self"><a href="#proc-self" class="headerlink" title="/proc/self"></a>/proc/self</h2><p>当进程访问此魔术符号链接时，它将解析到进程自己的/ proc / [pid]目录。</p>
<h2 id="proc-thread-self"><a href="#proc-thread-self" class="headerlink" title="/proc/thread-self"></a>/proc/thread-self</h2><p>当线程访问此魔术符号链接时，它将解析到进程自己的/ proc / self / task / [tid]目录。</p>
<h2 id="proc-a-z"><a href="#proc-a-z" class="headerlink" title="/proc/[a-z]*"></a>/proc/[a-z]*</h2><p>/ proc下的各种其他文件和子目录公开了系统范围的信息</p>
<h1 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h1><h2 id="proc-pid"><a href="#proc-pid" class="headerlink" title="/proc/[pid]"></a>/proc/[pid]</h2><p>每个正在运行的进程都有一个数字子目录。 子目录由进程ID命名。 每个此类子目录包含以下伪文件和目录。</p>
<h2 id="proc-pid-attr"><a href="#proc-pid-attr" class="headerlink" title="/proc/[pid]/attr"></a>/proc/[pid]/attr</h2><p>该目录中的文件提供了安全模块的API。此目录的内容是可以读写的文件，用于设置与安全相关的属性。 添加该目录是为了支持SELinux，但目的是使该API具有足够的通用性以支持其他安全模块。 为了便于说明，下面提供了SELinux如何使用这些文件的示例。</p>
<p>仅当内核配置了CONFIG_SECURITY时，此目录才存在。（和selinux有关，暂且忽略子文件）</p>
<h2 id="proc-pid-autogroup"><a href="#proc-pid-autogroup" class="headerlink" title="/proc/[pid]/autogroup"></a>/proc/[pid]/autogroup</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7)</a></p>
<p>此功能需要 CPU的CFS调度和内核配置CONFIG_SCHED_AUTOGROUP。在一个正在运行的系统，此功能通过文件启用或禁用/ proc / sys / kernel / sched_autogroup_enabled；值为0将禁用功能，而值1启用它。在此文件的默认值为1，除非内核使用noautogroup参数启动。</p>
<p>![image-20200831134847492](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831134847492.png)</p>
<h2 id="proc-pid-auxv"><a href="#proc-pid-auxv" class="headerlink" title="/proc/[pid]/auxv"></a>/proc/[pid]/auxv</h2><p>它包含在执行时传递给进程的ELF解释器信息的内容。每个条目的格式为一个无符号长ID加上一个无符号long 值。最后一个条目包含两个零。 另请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/getauxval.3.html">getauxval（3）</a>。</p>
<h2 id="proc-pid-cgroup"><a href="#proc-pid-cgroup" class="headerlink" title="/proc/[pid]/cgroup"></a>/proc/[pid]/cgroup</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups(7)</a>.</p>
<p>控制组（通常称为cgroup）是一种Linux内核功能，它允许将进程组织为分层组，然后可以限制和监视各种资源的使用。 内核的cgroup接口通过称为cgroupfs的伪文件系统提供。 分组是在核心cgroup内核代码中实现的，而资源跟踪和限制是在一组每个资源类型的子系统（内存，CPU等）中实现的。</p>
<h2 id="proc-pid-clear-refs"><a href="#proc-pid-clear-refs" class="headerlink" title="/proc/[pid]/clear_refs"></a>/proc/[pid]/clear_refs</h2><p>这是一个只写文件，只能由该文件的所有进程写入。可写入的值为1～5。和进程内存页的标记有关（内存回收时相关的页面标记）</p>
<h2 id="proc-pid-cmdline"><a href="#proc-pid-cmdline" class="headerlink" title="/proc/[pid]/cmdline"></a>/proc/[pid]/cmdline</h2><p>该只读文件包含该进程的完整命令行，除非该过程是僵尸程序。 在后一种情况下，该文件中没有任何内容：也就是说，对该文件的读取将返回0个字符。 命令行参数在此文件中显示为一组由空字节（’\ 0’）分隔的字符串，在最后一个字符串之后还有一个空字节。</p>
<h2 id="proc-pid-comm"><a href="#proc-pid-comm" class="headerlink" title="/proc/[pid]/comm"></a>/proc/[pid]/comm</h2><p>该文件公开了进程的comm值，即与该进程关联的命令名称。 同一进程中的不同线程可能具有不同的comm值，可通过/ proc / [pid] / task / [tid] / comm访问。 线程可以通过写入文件/ proc / self / task / [tid] / comm来修改其comm值，或同一线程组中任何其他线程的comm值（请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/clone.2.html">clone（2）</a>中对CLONE_THREAD的讨论） 长度超过TASK_COMM_LEN（16）个字符（包括终止空字节）的字符串将被静默截断。</p>
<p>![image-20200831141121137](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831141121137.png)</p>
<h2 id="proc-pid-coredump-filter"><a href="#proc-pid-coredump-filter" class="headerlink" title="/proc/[pid]/coredump_filter"></a>/proc/[pid]/coredump_filter</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/proc.5.html">core(5)</a></p>
<p>从内核2.6.23开始，特定于Linux的/ proc / [pid] / coredump_filter 该文件可用于控制将哪些内存段写入。如果执行了核心转储，则核心转储文件具有相应进程ID的进程。</p>
<h2 id="proc-pid-cpuset"><a href="#proc-pid-cpuset" class="headerlink" title="/proc/[pid]/cpuset"></a>/proc/[pid]/cpuset</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/cpuset.7.html">cpuset(7)</a>.</p>
<p>cpuset文件系统是内核cpuset机制的伪文件系统接口，用于控制进程的处理器的处理器位置和内存位置。 它通常安装在/ dev / cpuset上。</p>
<h2 id="proc-pid-cwd"><a href="#proc-pid-cwd" class="headerlink" title="/proc/[pid]/cwd"></a>/proc/[pid]/cwd</h2><p>这是指向该进程当前工作目录的符号链接。 例如，要查找进程20的当前工作目录，可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;proc&#x2F;20&#x2F;cwd; pwd -P</span><br></pre></td></tr></table></figure>
<h2 id="proc-pid-environ"><a href="#proc-pid-environ" class="headerlink" title="/proc/[pid]/environ"></a>/proc/[pid]/environ</h2><p>该文件包含通过execve（2）启动当前正在执行的程序时设置的初始环境。这些条目由空字节（’\ 0’）分隔，并且末尾可能会有一个空字节。 因此，要打印出进程1的environment，您可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;1&#x2F;environ | tr &#39;\000&#39; &#39;\n&#39;</span><br></pre></td></tr></table></figure>
<p>如果在execve（2）之后，该进程修改了其环境例如，通过调用诸如<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/putenv.3.html">putenv</a>之类的函数或修改<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/environ.7.html">environ</a>变量，此文件将不会反映</p>
<h2 id="proc-pid-exe"><a href="#proc-pid-exe" class="headerlink" title="/proc/[pid]/exe"></a>/proc/[pid]/exe</h2><p>在Linux 2.2及更高版本中，此文件是一个符号链接，其中包含已执行命令的实际路径名。 可以正常取消引用此符号链接。 尝试将其打开将打开可执行文件。 您甚至可以键入/ proc / [pid] / exe来运行由进程[pid]运行的同一可执行文件的另一个副本。 如果已取消链接路径名，则符号链接将包含附加在原始路径名后的字符串“（已删除）”。 在多线程进程中，如果主线程已经终止（通常通过调用pthread_exit（3）），则此符号链接的内容不可用。</p>
<p>![image-20200831142847138](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831142847138.png)</p>
<h2 id="proc-pid-fd"><a href="#proc-pid-fd" class="headerlink" title="/proc/[pid]/fd/"></a>/proc/[pid]/fd/</h2><p>这是一个子目录，其中包含该进程打开的每个文件的一个条目，该条目由其文件描述符命名，并且是指向实际文件的符号链接。 因此，0是标准输入，1是标准输出，2是标准错误，依此类推。</p>
<h2 id="proc-pid-fdinfo"><a href="#proc-pid-fdinfo" class="headerlink" title="/proc/[pid]/fdinfo/"></a>/proc/[pid]/fdinfo/</h2><p>这是一个子目录，其中包含该进程打开的每个文件的一个条目，该条目由其文件描述符命名。 该目录中的文件仅由进程所有者读取。 可以读取每个文件的内容以获得有关相应文件描述符的信息。 内容取决于相应文件描述符引用的文件类型。</p>
<p>![image-20200831143837694](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831143837694.png)</p>
<p>pos：这是一个十进制数字，显示文件偏移量。</p>
<p>flags：这是一个八进制数字，显示文件访问 模式和文件状态标志（请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/open.2.html">open（2）</a>）</p>
<p>mnt_id：包含此文件的挂载点。 见说明 / proc / [pid] / mountinfo。</p>
<h2 id="proc-pid-gid-map"><a href="#proc-pid-gid-map" class="headerlink" title="/proc/[pid]/gid_map"></a>/proc/[pid]/gid_map</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/user_namespaces.7.html">user_namespaces(7)</a></p>
<p>该映射告诉我们，该命名空间中以用户ID 0开始的范围映射到（不存在的）父命名空间中以0开始的范围，并且该范围的长度是最大的32位无符号整数。 这样就不会映射4294967295（32位带符号-1值）。 这是故意的：（uid_t）-1在多个接口（例如setreuid（2））中用作指定“无用户ID”的方式。 保留（uid_t）-1未映射和不可用的保证是，使用这些接口时不会造成混乱。</p>
<p>![image-20200831144505340](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831144505340.png)</p>
<h2 id="proc-pid-io"><a href="#proc-pid-io" class="headerlink" title="/proc/[pid]/io"></a>/proc/[pid]/io</h2><p>该文件包含该进程的I / O统计信息，例如：</p>
<p>![image-20200831144606851](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831144606851.png)</p>
<p>rchar：读取的字符<br>    导致此任务从存储中读取的字节数。这只是该进程传递给read（2）和类似系统调用的字节总和。它包括诸如终端I / O之类的内容，并且不受是否需要实际的物理磁盘I / O的影响（可能已从页面缓存中满足读取要求）。</p>
<p>wchar：编写的字符<br>    此任务已导致或应导致将其写入磁盘的字节数。与rchar相似的注意事项也适用于此。</p>
<p>syscr：读取syscalls<br>    尝试计算读取I / O操作的数量-即系统调用，例如read（2）和pread（2）。</p>
<p>syscw：编写系统调用<br>    尝试计算写I / O操作的数量，即，诸如write（2）和pwrite（2）之类的系统调用。</p>
<p>read_bytes：读取的字节<br>    尝试计算此过程确实导致从存储层获取的字节数。这对于块支持的文件系统是准确的。</p>
<p>write_bytes：写入的字节<br>       尝试计算此过程导致发送到存储层的字节数。</p>
<p>cancelled_write_bytes：<br>    这里最大的错误是截断。如果某个进程将1 MB写入文件，然后删除该文件，则实际上不会执行任何写出操作。但这将导致1 MB的写入。换句话说：该字段表示通过截断页面缓存而导致此过程未发生的字节数。任务也可能导致“负” I / O。如果此任务截断了一些脏的页面缓存，则不会发生已经考虑了另一个任务的某些I / O（以其write_bytes为单位）。</p>
<h2 id="proc-pid-limits"><a href="#proc-pid-limits" class="headerlink" title="/proc/[pid]/limits"></a>/proc/[pid]/limits</h2><p>该文件显示每个进程的资源限制的软限制，硬限制和度量单位（请参阅<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit（2）</a>）。 在Linux 2.6.35（含）之前，该文件受保护以允许仅由进程的实际UID进行读取。 从Linux 2.6.36开始，系统上的所有用户都可以读取此文件。</p>
<p>![image-20200831145313886](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831145313886.png)</p>
<h2 id="proc-pid-map-files"><a href="#proc-pid-map-files" class="headerlink" title="/proc/[pid]/map_files/"></a>/proc/[pid]/map_files/</h2><p>该子目录包含与内存映射文件相对应的条目（请参见mmap（2））。 条目由存储区开始和结束的地址对（以十六进制数字表示）命名，并且是映射文件本身的符号链接。 </p>
<p>![image-20200831145531323](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831145531323.png)</p>
<h2 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/[pid]/maps"></a>/proc/[pid]/maps</h2><p>包含当前映射的内存区域和他们的访问权限。有关内存映射的信息。请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap（2）</a>。</p>
<p>该文件的格式为：</p>
<p>![image-20200831145845967](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831145845967.png)</p>
<ul>
<li><p>address：地址字段是映射在进程中占用的地址空间。</p>
</li>
<li><p>perms：是一组权限</p>
<ul>
<li><pre><code>r = read
w = write
x = execute
s = shared
p = private (copy on write)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- offset：当虚拟内存区域是由一个文件通过mmap映射时，指明该虚拟内存区域的偏移量；如果不是其它文件映射，值为0</span><br><span class="line"></span><br><span class="line">- dev：device (major:minor)</span><br><span class="line"></span><br><span class="line">- inode：inode是该设备上的inode。0表示没有inode与内存区域关联，就像BSS（未初始化的数据）一样。</span><br><span class="line"></span><br><span class="line">- pathname：路径名字段通常将是支持映射的文件。 对于ELF文件，您可以通过查看ELF程序标头（readelf -l）中的Offset字段轻松地与offset字段进行协调。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    还有其他有用的伪路径：</span><br><span class="line">    [stack]：初始进程（也称为主线程）堆栈。</span><br><span class="line">    [stack:&lt;tid&gt;]：线程的堆栈（其中&lt;tid&gt;是线程ID）。 它对应于&#x2F; proc &#x2F; [pid] &#x2F; task &#x2F; [tid] &#x2F;路径。 在Linux 4.5中已删除了该字段，因为为具有大量线程的进程提供此信息非常昂贵。</span><br><span class="line">    [vdso]：虚拟动态链接的共享对象。 See vdso(7).</span><br><span class="line">    [heap] The process&#39;s heap.</span><br><span class="line">    </span><br><span class="line">    如果路径名字段为空，则这是通过mmap（2）获得的匿名映射</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="proc-pid-mem"><a href="#proc-pid-mem" class="headerlink" title="/proc/[pid]/mem"></a>/proc/[pid]/mem</h2><p>该文件可用于通过open（2），read（2）和lseek（2）访问进程的内存页面。</p>
<h2 id="proc-pid-mountinfo"><a href="#proc-pid-mountinfo" class="headerlink" title="/proc/[pid]/mountinfo"></a>/proc/[pid]/mountinfo</h2><p>该文件包含有关进程的mount 命名空间中的mount点的信息（请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html">mount_namespaces（7）</a>）。</p>
<p>文件格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">36 35 98:0 &#x2F;mnt1 &#x2F;mnt2 rw,noatime master:1 - ext3 &#x2F;dev&#x2F;root rw,errors&#x3D;continue</span><br><span class="line">(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)</span><br></pre></td></tr></table></figure>
<ol>
<li>mount ID: a unique ID for the mount</li>
<li>parent ID: the ID of the parent mount ( 或者是  mount namespace 挂载树的 root).</li>
<li>major：minor：此文件系统上文件的st_dev值（请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/stat.2.html">stat（2）</a>）</li>
<li>root：文件系统中目录的路径名，该目录构成此挂载的根目录。</li>
<li>mount point:：相对于进程根目录的挂载点的路径名。</li>
<li>mount options: per-mount options</li>
<li>可选字段：零个或多个“ tag [：value]”形式的字段；</li>
<li>分隔符：可选字段的末尾用单个连接符标记。</li>
<li>文件系统类型：文件系统类型，格式为“ type [.subtype]”。</li>
<li>挂载源：文件系统特定的信息或“无”。</li>
<li>super options: per-superblock options (see mount(2)).</li>
</ol>
<p>当前，可能的可选字段是shared，master，propagate_from和unbindable。 有关这些字段的描述，请参见mount_namespaces（7）。 解析器应忽略所有无法识别的可选字段。</p>
<h2 id="proc-pid-mounts"><a href="#proc-pid-mounts" class="headerlink" title="/proc/[pid]/mounts"></a>/proc/[pid]/mounts</h2><p>该文件列出了当前在进程的mount namespace中挂载的所有文件系统（请参见mount_namespaces（7））。 该文件的格式记录在fstab（5）中。</p>
<h2 id="proc-pid-mountstats"><a href="#proc-pid-mountstats" class="headerlink" title="/proc/[pid]/mountstats"></a>/proc/[pid]/mountstats</h2><p>该文件导出有关进程的mount namespace 中的mount点的信息（统计信息，配置信息）（请参见mount_namespaces（7））。 此文件中的行格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device &#x2F;dev&#x2F;sda7 mounted on &#x2F;home with fstype ext3 [stats]</span><br><span class="line">(       1      )            ( 2 )             (3 ) (  4  )</span><br></pre></td></tr></table></figure>
<ol>
<li>The name of the mounted device (or “nodevice”如果没有相应设备).</li>
<li>The mount point within the filesystem tree.</li>
<li>The filesystem type.</li>
<li>可选统计信息和配置信息.  Currently (as at Linux 2.6.26), only NFS filesystems export information via this field.</li>
</ol>
<h2 id="proc-pid-net"><a href="#proc-pid-net" class="headerlink" title="/proc/[pid]/net"></a>/proc/[pid]/net</h2><p>See the description of /proc/net.</p>
<h2 id="proc-pid-ns"><a href="#proc-pid-ns" class="headerlink" title="proc/[pid]/ns/"></a>proc/[pid]/ns/</h2><p>这是一个子目录，每个子目录包含一个条目，该条目支持由<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/setns.2.html">setns（2）</a>操纵。</p>
<h2 id="proc-pid-numa-maps"><a href="#proc-pid-numa-maps" class="headerlink" title="/proc/[pid]/numa_maps"></a>/proc/[pid]/numa_maps</h2><p>该文件显示有关进程的NUMA内存策略和分配的信息。</p>
<p>每行包含有关进程使用的内存范围的信息，除其他信息外，还显示该内存范围的有效内存策略以及在页面上分配了哪些节点。<br>numa_maps是只读文件。 读取/ proc / <pid> / numa_maps时，内核将扫描进程的虚拟地址空间并报告如何使用内存。 对于该进程的每个唯一存储范围，仅显示一行。</p>
<p>每行的第一字段显示存储范围的起始地址。 该字段允许与/ proc / <pid> / maps文件的内容相关联，该文件包含范围的结束地址和其他信息，例如访问权限和共享。</p>
<h2 id="proc-pid-oom-adj"><a href="#proc-pid-oom-adj" class="headerlink" title="/proc/[pid]/oom_adj"></a>/proc/[pid]/oom_adj</h2><p>该文件可用于调整分数，以选择在内存不足（OOM）情况下应杀死哪个进程。内核使用此值对进程的oom_score值进行移位操作：有效值位于 范围从-16到+15，再加上特殊值-17，这将完全禁用此进程的OOM杀死功能。 正数会增加这一过程被OOM杀死的可能性； 负数会降低可能性。</p>
<p>从Linux 2.6.36开始，不赞成使用此文件，而推荐使用/ proc / [pid] / oom_score_adj。</p>
<h2 id="proc-pid-oom-score"><a href="#proc-pid-oom-score" class="headerlink" title="/proc/[pid]/oom_score"></a>/proc/[pid]/oom_score</h2><p>该文件显示内核为此进程提供的当前分数，以选择OOM杀死的进程。 较高的分数意味着该进程更可能被OOM杀手选择。 该分数的基础是该进程使用的内存量。</p>
<p>oom_score还反映了该进程的oom_score_adj或oom_adj设置所指定的调整。</p>
<h2 id="proc-pid-oom-score-adj"><a href="#proc-pid-oom-score-adj" class="headerlink" title="/proc/[pid]/oom_score_adj"></a>/proc/[pid]/oom_score_adj</h2><p>该文件可用于调整挑选规则，用于选择在内存不足的情况下杀死哪个进程。</p>
<p>此方法会为每个候选任务分配一个值，范围从0（从不杀死）到1000（始终被杀死），以确定目标进程。 这些单元沿着其当前内存和交换使用的估计，大致是该进程可以从其分配的允许内存范围内的比例。 例如，如果一个任务正在使用所有允许的内存，则其不良得分将为1000。如果它使用了其允许的内存的一半，则其得分将为500。</p>
<h2 id="proc-pid-pagemap"><a href="#proc-pid-pagemap" class="headerlink" title="/proc/[pid]/pagemap"></a>/proc/[pid]/pagemap</h2><p>该文件显示了进程的每个虚拟页面到物理页面框架或交换区域的映射。 它为每个虚拟页面包含一个64位值，其位设置如下：</p>
<pre><code>63：如果已设置，则页面存在于RAM中。   
62：如果已设置，则页面位于交换空间中
61：（自Linux 3.5起）该页面是文件映射页面或共享的匿名页面
60–57：（自Linux 3.11起）零
56：（从Linux 4.2开始）该页面是唯一映射的。
55（从Linux 3.11开始）PTE是软脏的（请参阅内核源文件Documen-tation / admin-guide / mm / soft-dirty.rst）。
54-0：如果页面存在于RAM中（位63），则这些位提供页面框架号，可用于索引/ proc / kpageflags和/ proc / kpagecount。 如果页面存在于交换中（位62），然后位4-0给出交换类型，位54-5编码交换偏移量。</code></pre>
<p>问题：未发现64位值，是否需要从 maps中，找到其对应的地址，然后查看对应地址后的64位值</p>
<h2 id="proc-pid-personality"><a href="#proc-pid-personality" class="headerlink" title="/proc/[pid]/personality"></a>/proc/[pid]/personality</h2><p>该只读文件公开了由<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/personality.2.html">personality（2）</a>设置的进程的执行域（execute domain）。 该值以十六进制表示。</p>
<p>Linux为每个进程支持不同的执行域或个性（personalities）。 执行域除其他外还告诉Linux如何将信号编号映射为信号动作。 执行域系统允许Linux为在其他类似UNIX的操作系统下编译的二进制文件提供有限的支持。</p>
<p>问题：执行域是什么，有什么用？</p>
<h2 id="proc-pid-root"><a href="#proc-pid-root" class="headerlink" title="/proc/[pid]/root"></a>/proc/[pid]/root</h2><p>UNIX和Linux支持通过chroot（2）系统调用设置文件系统的按进程根目录的想法。 该文件是指向进程根目录的符号链接，其行为与exe和fd / *相同。</p>
<h2 id="proc-pid-seccomp"><a href="#proc-pid-seccomp" class="headerlink" title="/proc/[pid]/seccomp"></a>/proc/[pid]/seccomp</h2><p>该文件可用于读取和更改进程的安全计算（seccomp）模式设置。 如果进程不在seccomp模式下，则其值为0；如果进程在严格seccomp模式下，则其值为1（请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp（2）</a>）。 向该文件写入1将使进程不可逆地进入严格的seccomp模式。 （由于EPERM错误，进一步尝试写入文件失败。）</p>
<p>问题：未发现此文件，seccomp作用是什么？</p>
<h2 id="proc-pid-setgroups"><a href="#proc-pid-setgroups" class="headerlink" title="/proc/[pid]/setgroups"></a>/proc/[pid]/setgroups</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/user_namespaces.7.html">user_namespaces(7)</a></p>
<p>如果允许包含进程pid的用户名称空间中的进程使用setgroups（2）系统调用，则/ proc / [pid] / setgroups文件将显示字符串“ allow”。 如果在该用户名称空间中不允许使用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/setgroups.2.html">setgroups（2）</a>，它将显示“ deny”。 请注意，无论/ proc / [pid] / setgroups文件中的值如何（以及该进程的功能如何），如果尚未设置/ proc / [pid] / gid_map，也不允许调用setgroups（2） 。</p>
<h2 id="proc-pid-smaps"><a href="#proc-pid-smaps" class="headerlink" title="/proc/[pid]/smaps"></a>/proc/[pid]/smaps</h2><p>该文件显示了每个进程映射的内存消耗。 （pmap（1）命令以更易于解析的形式显示类似的信息。）对于每个映射，都有一系列的行，每一条记录（如下图2所示）表示进程虚拟内存空间中一块连续的区域。</p>
<p>![image-20200831165329516](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831165329516.png)</p>
<p>其中第一行从左到右依次表示地址范围、权限标识、映射文件偏移、设备号、inode、文件路径。</p>
<p>Size：表示该映射区域在虚拟内存空间中的大小。</p>
<p>Rss：表示该映射区域当前在物理内存中占用了多少空间。</p>
<p>Shared_Clean：和其他进程共享的未被改写的page的大小。</p>
<p>Shared_Dirty： 和其他进程共享的被改写的page的大小。</p>
<p>Private_Clean：未被改写的私有页面的大小。</p>
<p>Swap：表示非mmap内存（也叫anonymous memory，比如malloc动态分配出来的内存）由于物理内存不足被swap到交换空间的大小。</p>
<p>Pss：该虚拟内存区域平摊计算后使用的物理内存大小(有些内存会和其他进程共享，例如mmap进来的)。比如该区域所映射的物理内存部分同时也被另一个进程映射了，且该部分物理内存的大小为1000KB，那么该进程分摊其中一半的内存，即Pss=500KB。</p>
<h2 id="proc-pid-stack"><a href="#proc-pid-stack" class="headerlink" title="/proc/[pid]/stack"></a>/proc/[pid]/stack</h2><p>该文件提供了此进程的内核堆栈中函数调用的符号跟踪。 仅当内核使用CONFIG_STACKTRACE配置选项构建时才提供此文件。</p>
<p>![image-20200831165459751](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831165459751.png)</p>
<h2 id="proc-pid-stat"><a href="#proc-pid-stat" class="headerlink" title="/proc/[pid]/stat"></a>/proc/[pid]/stat</h2><p>有关进程的状态信息。 ps（1）使用它。它在内核源文件fs / proc / array.c中定义。解释暂且忽略，见官网</p>
<p>![image-20200831165737993](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831165737993.png)</p>
<h2 id="proc-pid-statm"><a href="#proc-pid-statm" class="headerlink" title="/proc/[pid]/statm"></a>/proc/[pid]/statm</h2><p>提供有关内存使用情况的信息，以页为单位。</p>
<p>size:任务虚拟地址空间大小</p>
<p>Resident：正在使用的物理内存大小</p>
<p>Shared：共享页数</p>
<p>Trs：程序所拥有的可执行虚拟内存大小</p>
<p>Lrs：被映像倒任务的虚拟内存空间的库的大小</p>
<p>Drs：程序数据段和用户态的栈的大小</p>
<p>Dt：脏页数量</p>
<p>![image-20200831165900516](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831165900516.png)</p>
<h2 id="proc-pid-status"><a href="#proc-pid-status" class="headerlink" title="/proc/[pid]/status"></a>/proc/[pid]/status</h2><p>以易于人类解析的格式在/ proc / [pid] / stat和/ proc / [pid] / statm中提供许多信息。解释见官网</p>
<p>![image-20200831170127994](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831170127994.png)</p>
<h2 id="proc-pid-syscall"><a href="#proc-pid-syscall" class="headerlink" title="/proc/[pid]/syscall"></a>/proc/[pid]/syscall</h2><p>该文件显示该进程当前正在执行的系统调用的系统调用号和参数寄存器，然后是堆栈指针和程序计数器寄存器的值。 尽管大多数系统调用使用较少的寄存器，但所有六个变量寄存器的值均公开。</p>
<p>![image-20200831170325597](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831170325597.png)</p>
<h2 id="proc-pid-task"><a href="#proc-pid-task" class="headerlink" title="/proc/[pid]/task"></a>/proc/[pid]/task</h2><p>该目录包含进程中每个线程的一个子目录。 每个子目录的名称是线程的数字线程ID（[tid]）（请参阅gettid（2））。</p>
<p>在每个子目录中，都有一组文件，它们的名称和内容与/ proc / [pid]目录下的文件相同。 对于所有线程共享的属性，任务/ [tid]子目录下每个文件的内容将与父/ proc / [pid]目录中相应文件中的内容相同（例如，在多线程进程中） ，所有task / [tid] / cwd文件将具有与父目录中的/ proc / [pid] / cwd文件相同的值，因为进程中的所有线程共享一个工作目录。 对于每个线程不同的属性，task/ [tid]下的相应文件可能具有不同的值（例如，每个线程的task/[tid]/status文件中的各个字段可能不同），或者它们可能在 / proc / [pid]中根本不存在。</p>
<h2 id="proc-pid-task-tid-children"><a href="#proc-pid-task-tid-children" class="headerlink" title="/proc/[pid]/task/[tid]/children"></a>/proc/[pid]/task/[tid]/children</h2><p>以空格分隔的此任务的子任务列表。 每个子任务由其TID表示。</p>
<p>![image-20200831171329521](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831171329521.png)</p>
<h2 id="proc-pid-timers"><a href="#proc-pid-timers" class="headerlink" title="/proc/[pid]/timers"></a>/proc/[pid]/timers</h2><p>此过程的POSIX计时器列表。 每个计时器都以一行以“ ID：”开头的行列出。 解释见官方，例如：</p>
<p>![image-20200831171431430](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831171431430.png)</p>
<h2 id="proc-pid-timerslack-ns"><a href="#proc-pid-timerslack-ns" class="headerlink" title="/proc/[pid]/timerslack_ns"></a>/proc/[pid]/timerslack_ns</h2><p>该文件不存在</p>
<h2 id="proc-pid-wchan"><a href="#proc-pid-wchan" class="headerlink" title="/proc/[pid]/wchan"></a>/proc/[pid]/wchan</h2><p>符号名称与进程在睡眠中的内核位置相对应。</p>
<h2 id="proc-tid"><a href="#proc-tid" class="headerlink" title="/proc/[tid]"></a>/proc/[tid]</h2><p>每个正在运行的线程都有一个数字子目录，该目录不是线程组领导者（即，其线程ID与进程ID不同的线程）； 子目录由线程ID命名。 这些子目录中的每个子目录都包含文件和子目录，这些文件和子目录公开了有关线程ID为tid的线程的信息。 这些目录的内容与相应的/ proc / [pid] / task / [tid]目录相同。</p>
<h2 id="proc-apm"><a href="#proc-apm" class="headerlink" title="/proc/apm"></a>/proc/apm</h2><p>在内核编译时定义CONFIG_APM时，高级电源管理版本和电池信息。</p>
<h2 id="proc-buddyinfo"><a href="#proc-buddyinfo" class="headerlink" title="/proc/buddyinfo"></a>/proc/buddyinfo</h2><p>该文件包含用于诊断内存碎片问题的信息。 每行以节点的标识和区域的名称开头，共同标识一个存储区域。 然后，在这些区域中按一定顺序对可用块进行计数。 特定顺序的字节大小由以下公式给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2^order) * PAGE_SIZE</span><br></pre></td></tr></table></figure>
<p>内核内部的二进制伙伴分配器算法会将一个块拆分为两个较小顺序的块（因此大小为原来的一半），或者将两个连续的块合并为一个较高顺序的较大块（因此大小为原来的两倍），以满足分配请求 并应对内存碎片。 当从零开始计数时，该顺序与列号匹配。</p>
<p>![image-20200831173112445](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831173112445.png)</p>
<p>在此示例中，有一个节点包含三个区域，并且有11种不同的块大小。 如果页面大小为4 KB，则第一个称为DMA的区域（在x86上为前16 MB内存）具有1个4 KB块（0阶）可用，并具有3个4 MB的块（10阶）可用。</p>
<p>如果内存严重碎片化，则高阶块的计数器将为零，大连续区域的分配将失败。</p>
<h2 id="proc-bus"><a href="#proc-bus" class="headerlink" title="/proc/bus"></a>/proc/bus</h2><p>包含已安装总线的子目录。</p>
<h2 id="proc-bus-pccard"><a href="#proc-bus-pccard" class="headerlink" title="/proc/bus/pccard"></a>/proc/bus/pccard</h2><p>在内核编译时设置CONFIG_PCMCIA时，PCMCIA设备的子目录。</p>
<h2 id="proc-bus-pci"><a href="#proc-bus-pci" class="headerlink" title="/proc/bus/pci"></a>/proc/bus/pci</h2><p>包含各种总线子目录和伪文件，这些伪文件包含有关PCI总线，已安装设备和设备驱动程序的信息。 其中一些文件不是ASCII。</p>
<h2 id="proc-bus-pci-devices"><a href="#proc-bus-pci-devices" class="headerlink" title="/proc/bus/pci/devices"></a>/proc/bus/pci/devices</h2><p>Information about PCI devices.  They may be accessed through <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/lspci.8.html">lspci(8)</a> and <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/setpci.8.html">setpci(8)</a>.</p>
<h2 id="proc-cgroups"><a href="#proc-cgroups" class="headerlink" title="/proc/cgroups"></a>/proc/cgroups</h2><p>该文件包含有关编译到内核中的控制器的信息。 该文件内容的示例（为便于阅读而进行了重新格式化）如下：</p>
<p>![image-20200831173945982](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831173945982.png)</p>
<p>该文件中的字段从左到右为：</p>
<p>1.控制器的名称。</p>
<p>2.安装此控制器的cgroup层次结构的唯一ID。 如果将多个cgroup v1控制器绑定到同一层次结构，则每个控制器将在此字段中显示相同的层次结构ID。 如果出现以下情况，则此字段中的值将为0：<br>a）控制器未安装在cgroups v1层次结构上；<br>b）控制器绑定到cgroups v2单一统一层次结构； 要么<br>c）控制器被禁用（见下文）。</p>
<p>3.使用此控制器的此层次结构中的控制组数。</p>
<p>4.如果启用了此控制器，则此字段包含值1；如果已禁用（通过cgroup_disable内核命令行引导参数），则该字段包含值0。</p>
<h2 id="proc-cmdline"><a href="#proc-cmdline" class="headerlink" title="/proc/cmdline"></a>/proc/cmdline</h2><p>引导时将参数传递给Linux内核。 通常通过引导管理器（如lilo（8）或grub（8））完成。</p>
<p>![image-20200831174911159](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831174911159.png)</p>
<h2 id="proc-config-gz"><a href="#proc-config-gz" class="headerlink" title="/proc/config.gz"></a>/proc/config.gz</h2><p>该文件提供了用于构建当前正在运行的内核的配置选项，格式与配置内核时使用的.config文件中显示的格式相同（使用make xconfig，make config）。此文件内容被压缩； 使用zcat（1）和zgrep（1）查看或搜索它们。 只要未对以下文件进行任何更改，/ proc / config.gz的内容将与提供的内容相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;build&#x2F;.config</span><br></pre></td></tr></table></figure>
<h2 id="proc-crypto"><a href="#proc-crypto" class="headerlink" title="/proc/crypto"></a>/proc/crypto</h2><p>内核加密API提供的密码列表。 有关详细信息，请参阅内核源目录Documentation / crypto /（或4.10之前的Documentation / DocBook）下的内核Linux Kernel Crypto API文档；可使用诸如make htmldocs之类的命令在内核源树的根目录中构建该文档。 ）。</p>
<p>![image-20200831174853023](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831174853023.png)</p>
<h2 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h2><p>这是与CPU和系统体系结构相关的项的集合，对于每种受支持的体系结构，都有不同的列表。 两个常见的条目是处理器，它给出CPU编号和bogomips。 在内核初始化期间计算的系统常数。 SMP机器具有每个CPU的信息。 lscpu（1）命令从该文件收集其信息。</p>
<p>![image-20200831174934835](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831174934835.png)</p>
<h2 id="proc-devices"><a href="#proc-devices" class="headerlink" title="/proc/devices"></a>/proc/devices</h2><p>主号码和设备组的文本列表。 MAKEDEV脚本可以使用它来与内核保持一致。</p>
<p>![image-20200831175046761](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831175046761.png)</p>
<h2 id="proc-diskstats"><a href="#proc-diskstats" class="headerlink" title="/proc/diskstats"></a>/proc/diskstats</h2><p>该文件包含每个磁盘设备的磁盘I / O统计信息。有关更多信息，请参见Linux内核源文件Documentation / iostats.txt。</p>
<p>![image-20200831175136925](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831175136925.png)</p>
<h2 id="proc-dma"><a href="#proc-dma" class="headerlink" title="/proc/dma"></a>/proc/dma</h2><p>这是正在使用的已注册ISA DMA（直接内存访问）通道的列表。</p>
<p>![image-20200831175217854](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831175217854.png)</p>
<h2 id="proc-driver"><a href="#proc-driver" class="headerlink" title="/proc/driver"></a>/proc/driver</h2><p>该目录包含内核使用的特定驱动程序的信息。</p>
<p>此处找到一个通用文件rtc，该文件为驱动程序提供系统的实时时钟（RTC）的输出，该设备可在系统关闭时保持时间。 / proc / driver / rtc的示例输出如下所示：</p>
<p>![image-20200831175743359](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831175743359.png)</p>
<h2 id="proc-execdomains"><a href="#proc-execdomains" class="headerlink" title="/proc/execdomains"></a>/proc/execdomains</h2><p>该文件列出了Linux内核当前支持的执行域，以及它们支持的个性范围。</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831175948363.png" alt="image-20200831175948363" style="zoom:67%;" />

<p>将执行域视为操作系统的“个性”。因为其他二进制格式（例如Solaris，UnixWare和FreeBSD）可以与Linux一起使用，所以程序员可以通过更改任务的个性来更改操作系统处理来自这些二进制文件的系统调用的方式。除了PER_LINUX执行域外，可以将不同的角色实现为可动态加载的模块。</p>
<h2 id="proc-fb"><a href="#proc-fb" class="headerlink" title="/proc/fb"></a>/proc/fb</h2><p>在内核编译期间定义CONFIG_FB时的帧缓冲区信息。</p>
<h2 id="proc-filesystems"><a href="#proc-filesystems" class="headerlink" title="/proc/filesystems"></a>/proc/filesystems</h2><p>内核支持的文件系统的文本列表，即已编译到内核中或当前正在加载其内核模块的文件系统。 （另请参阅<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/filesystems.5.html">filesystem（5）</a>。）如果文件系统标记有“ nodev”，则意味着它不需要挂载块设备（例如，虚拟文件系统，网络文件系统）。</p>
<p>顺便说一句，当未指定文件系统并且无法确定文件系统类型时，mount（8）可能会使用该文件。 然后尝试包含在此文件中的文件系统（标有“ nodev”的文件系统除外）。</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831180258782.png" alt="image-20200831180258782" style="zoom:50%;" />

<h2 id="proc-fs"><a href="#proc-fs" class="headerlink" title="/proc/fs"></a>/proc/fs</h2><p>包含子目录，这些子目录又包含带有（某些）已安装文件系统信息的文件。</p>
<h2 id="proc-interrupts"><a href="#proc-interrupts" class="headerlink" title="/proc/interrupts"></a>/proc/interrupts</h2><p>这用于记录每个IO设备每个CPU的中断数。 从Linux 2.6.24开始，至少对于i386和x86-64体系结构，这还包括系统内部的中断（即与设备本身不相关的中断），例如NMI（不可屏蔽中断），LOC（本地计时器中断），而对于SMP系统，则是TLB（TLB刷新中断），RES（重调度中断），CAL（远程功能调用中断）等。 格式非常容易阅读，以ASCII完成。</p>
<p>![image-20200831180627372](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831180627372.png)</p>
<h2 id="proc-iomem"><a href="#proc-iomem" class="headerlink" title="/proc/iomem"></a>/proc/iomem</h2><p>此文件显示每个物理设备的系统内存的当前映射：</p>
<p>![image-20200831180823031](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831180823031.png)</p>
<p>第一列显示了每种不同类型的内存使用的内存寄存器。第二列列出了位于这些寄存器内的内存类型，并显示系统RAM内的 内核使用哪些内存寄存器；如果网络接口卡具有多个以太网端口，则为每个端口分配内存寄存器</p>
<h2 id="proc-ioports"><a href="#proc-ioports" class="headerlink" title="/proc/ioports"></a>/proc/ioports</h2><p>/ proc / ioports的输出提供了用于与设备进行输入或输出通信的当前注册端口区域的列表。该文件可能很长。以下是部分清单：</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831180952445.png" alt="image-20200831180952445" style="zoom: 50%;" />

<p>第一列给出了为第二列中列出的设备保留的I / O端口地址范围。</p>
<h2 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h2><p>它保存了modules（X）工具用来动态链接和绑定可加载模块的内核导出符号定义。 在Linux 2.5.47及更早版本中，一个语法稍有不同的相似文件称为ksyms。</p>
<p>![image-20200831181324897](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831181324897.png)</p>
<h2 id="proc-kcore"><a href="#proc-kcore" class="headerlink" title="/proc/kcore"></a>/proc/kcore</h2><p>该文件代表系统的物理内存，并以ELF核心文件格式存储。 使用此伪文件和未剥离的内核（/ usr / src / linux / vmlinux）二进制文件，可以使用GDB检查任何内核数据结构的当前状态。</p>
<p>文件的总长度是物理内存（RAM）的大小加上4 KiB。</p>
<h2 id="proc-keys"><a href="#proc-keys" class="headerlink" title="/proc/keys"></a>/proc/keys</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/keyrings.7.html">keyrings(7)</a></p>
<p>该文件公开了读取线程具有查看权限的键列表，并提供了有关每个键的各种信息。 线程不需要拥有密钥，该密钥在此文件中可见。</p>
<p>![image-20200831181834534](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831181834534.png)</p>
<h2 id="proc-key-users"><a href="#proc-key-users" class="headerlink" title="/proc/key-users"></a>/proc/key-users</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/keyrings.7.html">keyrings(7)</a></p>
<p>该文件列出了在系统上至少具有一个密钥的每个用户ID的各种信息。 下面是一个可能在此文件中看到的数据示例：</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831181721095.png" alt="image-20200831181721095" style="zoom:50%;" />

<h2 id="proc-kmsg"><a href="#proc-kmsg" class="headerlink" title="/proc/kmsg"></a>/proc/kmsg</h2><p>可以使用此文件代替syslog（2）系统调用来读取内核消息。 一个进程必须具有超级用户特权才能读取此文件，并且只有一个进程应读取该文件。 如果正在运行使用syslog（2）系统调用工具记录内核消息的syslog进程，则不应读取该文件。</p>
<p>该文件中的信息是使用dmesg（1）程序检索的。</p>
<h2 id="proc-kpagecount"><a href="#proc-kpagecount" class="headerlink" title="/proc/kpagecount"></a>/proc/kpagecount</h2><p>该文件包含每个物理页框架被映射次数的64位计数，该计数由页框架号索引（请参见对/ proc / [pid] / pagemap的讨论）。</p>
<h2 id="proc-kpageflags"><a href="#proc-kpageflags" class="headerlink" title="/proc/kpageflags"></a>/proc/kpageflags</h2><p>该文件包含与每个物理页面帧相对应的64位掩码。 它由页面框架号索引（请参见/ proc / [pid] / pagemap的讨论）。掩码详情参见官网</p>
<h2 id="proc-loadavg"><a href="#proc-loadavg" class="headerlink" title="/proc/loadavg"></a>/proc/loadavg</h2><p>该文件的前三个字段是平均负载数字，给出了运行队列（状态R）或等待磁盘I / O（状态D）在1分钟，5分钟和15分钟内的平均作业数，它们与 uptime（1）和其他程序给出的平均负载数一致。 第四个字段由两个数字组成，两个数字之间用斜杠（/）分隔。 其中第一个是当前可运行的内核调度实体的数量（进程，线程）。 斜杠后的值是系统上当前存在的内核调度实体的数量。 第五个字段是系统上最近创建的进程的PID。</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831184033694.png" alt="image-20200831184033694" style="zoom:50%;" />

<h2 id="proc-locks"><a href="#proc-locks" class="headerlink" title="/proc/locks"></a>/proc/locks</h2><p>此文件显示当前文件锁（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/flock.2.html">flock（2）</a>和<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl（2）</a>）和租约（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl（2）</a>）。</p>
<p>详解见官网，只是第6行的数字（13035，489）代表pid，第7行代表 major:minor:inode</p>
<p>![image-20200831184207334](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831184207334.png)</p>
<h2 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="/proc/meminfo"></a>/proc/meminfo</h2><p>该文件报告有关系统内存使用情况的统计信息。free（1）使用该文件报告系统上可用和已用内存（物理内存和交换内存）以及内核使用的共享内存和缓冲区的数量</p>
<p>MemTotal:</p>
<p>总可用RAM（即物理RAM减去几个保留位和内核二进制代码）。系统从加电开始到引导完成，firmware/BIOS要保留一些内存，kernel本身要占用一些内存，最后剩下可供kernel支配的内存就是MemTotal。这个值在系统运行期间一般是固定不变的。可参阅<a target="_blank" rel="noopener" href="http://linuxperf.com/?p=139">解读DMESG中的内存初始化信息</a>。</p>
<p>MemFree:</p>
<p>表示系统尚未使用的内存。[MemTotal-MemFree]就是已被用掉的内存。</p>
<p>MemAvailable:</p>
<p>有些应用程序会根据系统的可用内存大小自动调整内存申请的多少，所以需要一个记录当前可用内存数量的统计值，MemFree并不适用，因为MemFree不能代表全部可用的内存，系统中有些内存虽然已被使用但是可以回收的，比如cache/buffer、slab都有一部分可以回收，所以这部分可回收的内存加上MemFree才是系统可用的内存，即MemAvailable。/proc/meminfo中的MemAvailable是内核使用特定的算法估算出来的，要注意这是一个估计值，并不精确。</p>
<p>Buffers:</p>
<p>新的内核已经没有buffer cache了，一切都统一到了page cache的框架下了。因此，所谓的buffer cache就是块设备的page cache</p>
<p>Cached:</p>
<p>从磁盘读取的文件的内存缓存（页面缓存）。不包括SwapCached。</p>
<p>Page Cache里包括所有file-backed pages，统计在/proc/meminfo的”Cached”中。</p>
<p>Cached是”Mapped”的超集，就是说它不仅包括mapped，也包括unmapped的页面，当一个文件不再与进程关联之后，原来在page cache中的页面并不会立即回收，仍然被计入Cached，还留在LRU中，但是 Mapped 统计值会减小。【ummaped = (Cached – Mapped)】</p>
<p>“Cached”和”SwapCached”两个统计值是互不重叠的，源代码参见下一节。所以，Shared memory和tmpfs在不发生swap-out的时候属于”Cached”，而在swap-out/swap-in的过程中会被加进swap cache中、属于”SwapCached”，一旦进了”SwapCached”，就不再属于”Cached”了。</p>
<p>SwapCached:</p>
<p>曾经被换出的内存被换回，但仍在交换文件中。 （如果内存压力很大，则无需再次换出这些页面，因为它们已经在交换文件中。这可以节省I / O。）</p>
<p>Active:</p>
<p>最近使用多的内存，除非绝对必要，否则通常不会回收。等于Active(anon) + Active(file)的和</p>
<p>Inactive:</p>
<p>最近使用少的内存，更有可能被回收，等于Inactive(anon) + Inactive(file)的和</p>
<p>Active(anon):</p>
<p>Inactive(anon):</p>
<p>Active(file):</p>
<p>Inactive(file):</p>
<p>括号中为anon的内存为匿名内存，括号中为file的内存为file-backed内存，这两个内存的区别在于，物理内存的内容是否与物理磁盘上的文件相关联。</p>
<p> 其中，匿名内存就是进程中堆上分配的内存，是用malloc分配的内存。</p>
<p> 而file-backed内存为磁盘高速缓存的内存空间和“文件映射(将物理磁盘上的文件内容与用户进程的逻辑地址直接关联)”的内存空间，其中的内容与物理磁盘上的文件相对应。</p>
<p> 而Active和Inactive的区别在于内存空间中是否包含最近被使用过的数据。当物理内存不足，不得不释放正在使用的内存空间时，会优先释放Inactive的内存空间。</p>
<p>Linux内核中使用4类LRU表来分别记录对应的这4类内存页,内存页一般以4K为一页。</p>
<p>Unevictable:</p>
<p>有些内存页是不能被释放的，这些内存页不能放在LRU表中，而是记录到Unevictable表中</p>
<p>Mlocked:</p>
<p>“Mlocked”统计的是被mlock()系统调用锁定的内存大小。被锁定的内存因为不能pageout/swapout，会从Active/Inactive LRU list移到Unevictable LRU list上。也就是说，当”Mlocked”增加时，”Unevictable”也同步增加，而”Active”或”Inactive”同时减小；当”Mlocked”减小的时候，”Unevictable”也同步减小，而”Active”或”Inactive”同时增加。</p>
<p> “Mlocked”并不是独立的内存空间，它与以下统计项重叠：LRU Unevictable，AnonPages，Shmem，Mapped等</p>
<p>SwapTotal:</p>
<p>SwapFree:</p>
<p>Dirty:</p>
<p>/proc/meminfo 中有一个Dirty统计值，但是它未能包括系统中全部的dirty pages，应该再加上另外两项：NFS_Unstable 和 Writeback，NFS_Unstable是发给NFS server但尚未写入硬盘的缓存页，Writeback是正准备回写硬盘的缓存页。即：</p>
<p> 系统中全部dirty pages = ( Dirty + NFS_Unstable + Writeback )</p>
<p> Writeback:</p>
<p>正准备回写硬盘的缓存页</p>
<p>AnonPages:</p>
<p>前面提到用户进程的内存页分为两种：file-backed pages（与文件对应的内存页），和anonymous pages（匿名页）。Anonymous pages(匿名页)的数量统计在/proc/meminfo的AnonPages中。</p>
<p>以下是几个事实，有助于了解Anonymous Pages：</p>
<p> 所有page cache里的页面(Cached)都是file-backed pages，不是Anonymous Pages。”Cached”与”AnoPages”之间没有重叠。</p>
<p>注：shared memory 不属于 AnonPages，而是属于Cached，因为shared memory基于tmpfs，所以被视为file-backed、在page cache里，上一节解释过。</p>
<p>mmap private anonymous pages属于AnonPages(Anonymous Pages)，而mmap shared anonymous pages属于Cached(file-backed pages)，因为shared anonymous mmap也是基于tmpfs的，上一节解释过。</p>
<p>Anonymous Pages是与用户进程共存的，一旦进程退出，则Anonymous pages也释放，不像page cache即使文件与进程不关联了还可以缓存。</p>
<p> Mapped:</p>
<p>上面提到的用户进程的file-backed pages就对应着/proc/meminfo中的”Mapped”。Page cache中(“Cached”)包含了文件的缓存页，其中有些文件当前已不在使用，page cache仍然可能保留着它们的缓存页面；而另一些文件正被用户进程关联，比如shared libraries、可执行程序的文件、mmap的文件等，这些文件的缓存页就称为mapped。</p>
<p> /proc/meminfo中的”Mapped”就统计了page cache(“Cached”)中所有的mapped页面。”Mapped”是”Cached”的子集。</p>
<p> 因为Linux系统上shared memory &amp; tmpfs被计入page cache(“Cached”)，所以被attached的shared memory、以及tmpfs上被map的文件都算做”Mapped”。</p>
<p> 进程所占的内存页分为anonymous pages和file-backed pages，理论上应该有：</p>
<p>【所有进程的PSS之和】 == 【Mapped + AnonPages】。</p>
<p>然而我实际测试的结果，虽然两者很接近，却总是无法精确相等，我猜也许是因为进程始终在变化、采集的/proc/[1-9]*/smaps以及/proc/meminfo其实不是来自同一个时间点的缘故。</p>
<p> Shmem:</p>
<p>/proc/meminfo中的Shmem统计的内容包括：</p>
<p>u shared memory</p>
<p>u tmpfs和devtmpfs。</p>
<p>注：所有tmpfs类型的文件系统占用的空间都计入共享内存，devtmpfs是/dev文件系统的类型，/dev/下所有的文件占用的空间也属于共享内存。可以用ls和du命令查看。如果文件在没有关闭的情况下被删除，空间仍然不会释放，shmem不会减小，可以用 “lsof -a +L1 /<mount_point>” 命令列出这样的文件。</p>
<p>当shmget/shm_open/mmap创建共享内存时，物理内存尚未分配，要直到真正访问时才分配。/proc/meminfo中的 Shmem 统计的是已经分配的大小，而不是创建时申请的大小</p>
<p>Slab:</p>
<p>通过slab分配的内存，SReclaimable + SUnreclaim 之和</p>
<p>SReclaimable:</p>
<p>slab中可回收的部分</p>
<p>SUnreclaim:</p>
<p>slab中不可回收的部分</p>
<p>KernelStack:</p>
<p>每一个用户线程都会分配一个kernel stack（内核栈），内核栈虽然属于线程，但用户态的代码不能访问，只有通过系统调用(syscall)、自陷(trap)或异常(exception)进入内核态的时候才会用到，也就是说内核栈是给kernel code使用的。在x86系统上Linux的内核栈大小是固定的8K或16K（可参阅我以前的文章：<a target="_blank" rel="noopener" href="http://linuxperf.com/?p=116">内核栈溢出</a>）。</p>
<p> Kernel stack（内核栈）是常驻内存的，既不包括在LRU lists里，也不包括在进程的RSS/PSS内存里，所以我们认为它是kernel消耗的内存。统计值是/proc/meminfo的KernelStack。</p>
<p>PageTables:</p>
<p>Page Table用于将内存的虚拟地址翻译成物理地址，随着内存地址分配得越来越多，Page Table会增大，/proc/meminfo中的PageTables统计了Page Table所占用的内存大小。</p>
<p> 注：请把Page Table与Page Frame（页帧）区分开，物理内存的最小单位是page frame，每个物理页对应一个描述符(struct page)，在内核的引导阶段就会分配好、保存在mem_map[]数组中，mem_map[]所占用的内存被统计在dmesg显示的reserved中，/proc/meminfo的MemTotal是不包含它们的。（在NUMA系统上可能会有多个mem_map数组，在node_data中或mem_section中）。</p>
<p>而Page Table的用途是翻译虚拟地址和物理地址，它是会动态变化的，要从MemTotal中消耗内存。</p>
<p> NFS_Unstable:</p>
<p>NFS_Unstable是发给NFS server但尚未写入硬盘的缓存页,，NFS_Unstable的内存被包含在Slab中，因为nfs request内存是调用kmem_cache_zalloc()申请的</p>
<p>Bounce:</p>
<p>有些老设备只能访问低端内存，比如16M以下的内存，当应用程序发出一个I/O 请求，DMA的目的地址却是高端内存时（比如在16M以上），内核将在低端内存中分配一个临时buffer作为跳转，把位于高端内存的缓存数据复制到此处。这种额外的数据拷贝被称为“bounce buffering”，会降低I/O 性能。大量分配的bounce buffers 也会占用额外的内存。</p>
<p>WritebackTmp:</p>
<p>CommitLimit:</p>
<p>Committed_AS:</p>
<p>VmallocTotal:</p>
<p>VmallocUsed:</p>
<p>VmallocChunk:</p>
<p>HardwareCorrupted:</p>
<p>当系统检测到内存的硬件故障时，会把有问题的页面删除掉，不再使用，/proc/meminfo中的HardwareCorrupted统计了删除掉的内存页的总大小。相应的代码参见 mm/memory-failure.c: memory_failure()</p>
<p>AnonHugePages:</p>
<p>AnonHugePages统计的是Transparent HugePages (THP)，THP与Hugepages不是一回事，区别很大。</p>
<p> 而AnonHugePages完全不同，它与/proc/meminfo的其他统计项有重叠，首先它被包含在AnonPages之中，而且在/proc/<pid>/smaps中也有单个进程的统计，与进程的RSS/PSS是有重叠的，如果用户进程用到了THP，进程的RSS/PSS也会相应增加，这与Hugepages是不同的。</p>
<p> 因为缺省情况下shared memory和tmpfs不使用THP，所以进程之间不会共享AnonHugePages，于是就有以下等式：</p>
<p>【/proc/meminfo的AnonHugePages】==【所有进程的/proc/<pid>/smaps中AnonHugePages之和】</p>
<p>HugePages_Total:</p>
<p>HugePages_Free:</p>
<p>HugePages_Rsvd:</p>
<p>HugePages_Surp:</p>
<p>Hugepagesize:</p>
<p>Hugepages在/proc/meminfo中是被独立统计的，与其它统计项不重叠，既不计入进程的RSS/PSS中，又不计入LRU Active/Inactive，也不会计入cache/buffer。如果进程使用了Hugepages，它的RSS/PSS不会增加。</p>
<p> 注：不要把 Transparent HugePages (THP)跟 Hugepages 搞混了，THP的统计值是/proc/meminfo中的”AnonHugePages”，在/proc/<pid>/smaps中也有单个进程的统计，这个统计值与进程的RSS/PSS是有重叠的，如果用户进程用到了THP，进程的RSS/PSS也会相应增加，这与Hugepages是不同的。</p>
<p> HugePages_Total 对应内核参数 vm.nr_hugepages，也可以在运行中的系统上直接修改 /proc/sys/vm/nr_hugepages，修改的结果会立即影响空闲内存 MemFree的大小，因为HugePages在内核中独立管理，只要一经定义，无论是否被使用，都不再属于free memory。在下例中我们设置256MB(128页)Hugepages，可以立即看到Memfree立即减少了262144kB（即256MB）</p>
<p>DirectMap4k:</p>
<p>/proc/meminfo中的DirectMap所统计的不是关于内存的使用，而是一个反映TLB效率的指标。TLB(Translation Lookaside Buffer)是位于CPU上的缓存，用于将内存的虚拟地址翻译成物理地址，由于TLB的大小有限，不能缓存的地址就需要访问内存里的page table来进行翻译，速度慢很多。为了尽可能地将地址放进TLB缓存，新的CPU硬件支持比4k更大的页面从而达到减少地址数量的目的， 比如2MB，4MB，甚至1GB的内存页，视不同的硬件而定。”DirectMap4k”表示映射为4kB的内存数量， “DirectMap2M”表示映射为2MB的内存数量，以此类推。所以DirectMap其实是一个反映TLB效率的指标。</p>
<h2 id="proc-modules"><a href="#proc-modules" class="headerlink" title="/proc/modules"></a>/proc/modules</h2><p>系统已加载的模块的文本列表。 另请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/lsmod.8.html">lsmod（8）</a>。lsmod是一个简单的程序，可以很好地格式化/ proc / modules的内容，显示当前正在加载的内核模块。</p>
<h2 id="proc-mounts"><a href="#proc-mounts" class="headerlink" title="/proc/mounts"></a>/proc/mounts</h2><p>在内核2.4.19之前，此文件是系统上当前安装的所有文件系统的列表。 随着Linux 2.4.19中按进程的mount 命名空间的引入（请参见mount_namespaces（7）），此文件成为/ proc / self / mounts的链接，该文件列出了进程自己的mount命名空间的挂载点。 该文件的格式记录在fstab（5）中。</p>
<h2 id="proc-mtrr"><a href="#proc-mtrr" class="headerlink" title="/proc/mtrr"></a>/proc/mtrr</h2><p>存储器类型范围寄存器。 有关详细信息，请参见Linux内核源文件Documentation / x86 / mtrr.txt（或Linux 2.6.28之前的Documentation / mtrr.txt）。</p>
<p>![image-20200831212422642](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831212422642.png)</p>
<h2 id="proc-net"><a href="#proc-net" class="headerlink" title="/proc/net"></a>/proc/net</h2><p>该目录包含各种文件和子目录，这些文件和子目录包含有关网络层的信息。 这些文件包含ASCII结构，因此可以用cat（1）读取。 但是，标准的netstat（8）套件可以更干净地访问这些文件。</p>
<p>随着网络名称空间的出现，与网络堆栈有关的各种信息都已虚拟化（请参阅network_namespaces（7））。 因此，从Linux 2.6.25开始，/ proc / net是指向/ proc / self / net目录的符号链接，该目录包含与以下所列相同的文件和目录。 但是，这些文件和目录现在公开了该进程所属的网络名称空间的信息。</p>
<h2 id="proc-net-arp"><a href="#proc-net-arp" class="headerlink" title="/proc/net/arp"></a>/proc/net/arp</h2><p>它保存用于地址解析的内核ARP表的ASCII可读转储。 它将显示动态学习的和预处理的ARP条目。 格式为：</p>
<p>![image-20200831212801942](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831212801942.png)</p>
<p>这里的“ IP address”是机器的IPv4地址，“HW type”是RFC 826中地址的硬件类型。Flags是ARP结构的内部标志（在/ usr / include / linux /if_arp.h中定义） ）和“HW address”是该IP地址的数据链路层映射（如果已知）。</p>
<h2 id="proc-net-dev"><a href="#proc-net-dev" class="headerlink" title="/proc/net/dev"></a>/proc/net/dev</h2><p>dev伪文件包含网络设备状态信息。 这给出了接收和发送的数据包的数量，错误和冲突的数量以及其他基本统计信息。 ifconfig（8）程序使用它们来报告设备状态。 格式为：。</p>
<p><img src="file:////Users/shenshawn/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image001.png" alt="img"></p>
<p>l Bytes：接口发送或接收的数据的总字节数</p>
<p>l packets：接口发送或接收的数据包总数</p>
<p>l errs：由设备驱动程序检测到的发送或接收错误的总数</p>
<p>l drop：设备驱动程序丢弃的数据包总数</p>
<p>l fifo：分组帧错误的数量</p>
<p>l compressed：设备驱动程序发送或接收的压缩数据包数</p>
<p>l multicast：设备驱动程序发送或接受的多播帧数</p>
<p>l colls：接口上检测到的冲突数</p>
<p>l carrier：由设备驱动程序检测到的载波损耗的数量</p>
<h2 id="proc-net-dev-mcast"><a href="#proc-net-dev-mcast" class="headerlink" title="/proc/net/dev_mcast"></a>/proc/net/dev_mcast</h2><p>Defined in /usr/src/linux/net/core/dev_mcast.c:</p>
<p>包含设备正在侦听的第2层多播组（接口索引，标签，引用数，绑定地址数）。</p>
<p>![image-20200831213147513](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831213147513.png)</p>
<h2 id="proc-net-igmp"><a href="#proc-net-igmp" class="headerlink" title="/proc/net/igmp"></a>/proc/net/igmp</h2><p>定义于/usr/src/linux/net/core/igmp.c。</p>
<p>包含由该主机加入的IPv4组播组。</p>
<p>![image-20200831215934117](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831215934117.png)</p>
<h2 id="proc-net-rarp"><a href="#proc-net-rarp" class="headerlink" title="/proc/net/rarp"></a>/proc/net/rarp</h2><p>该文件使用与arp文件相同的格式，并且包含用于提供<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/rarp.8.html">rarp（8）</a>反向地址查找服务的当前反向映射数据库。 如果未在内核中配置RARP，则该文件将不存在。</p>
<h2 id="proc-net-raw"><a href="#proc-net-raw" class="headerlink" title="/proc/net/raw"></a>/proc/net/raw</h2><p>保存RAW套接字表的转储。 除调试外，许多信息都没有用。 “ sl”值是套接字的内核哈希槽，“ local_address”是本地地址和协议号对。 “ St”是套接字的内部状态。 就内核内存使用而言，“ tx_queue”和“ rx_queue”是传出和传入数据队列。 RAW不使用“ tr”，“ tm-&gt; when”和“ rexmits”字段。 “ uid”字段保存套接字创建者的有效UID。</p>
<p>![image-20200831220443419](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831220443419.png)</p>
<h2 id="proc-net-snmp"><a href="#proc-net-snmp" class="headerlink" title="/proc/net/snmp"></a>/proc/net/snmp</h2><p>该文件包含SNMP agent的IP，ICMP，TCP和UDP管理信息库所需的ASCII数据。</p>
<p>![image-20200831220626480](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831220626480.png)</p>
<h2 id="proc-net-tcp"><a href="#proc-net-tcp" class="headerlink" title="/proc/net/tcp"></a>/proc/net/tcp</h2><p>保存TCP套接字表的转储。 除调试外，许多信息都没有用。 “ sl”值是套接字的内核哈希槽，“ local_address”是本地地址和端口号对。 “ rem_address”是远程地址和端口号对（如果已连接）。 “ St”是套接字的内部状态。 就内核内存使用而言，“ tx_queue”和“ rx_queue”是传出和传入数据队列。 “ tr”，“ tm-&gt; when”和“ rexmits”字段保存内核套接字状态的内部信息，仅对调试有用。 “ uid”字段保存套接字创建者的有效UID。</p>
<p>![image-20200831220820566](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831220820566.png)</p>
<h2 id="proc-net-udp"><a href="#proc-net-udp" class="headerlink" title="/proc/net/udp"></a>/proc/net/udp</h2><p>保存UDP套接字表的转储。</p>
<p>![image-20200831220859989](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831220859989.png)</p>
<h2 id="proc-net-unix"><a href="#proc-net-unix" class="headerlink" title="/proc/net/unix"></a>/proc/net/unix</h2><p>列出系统中存在的UNIX域套接字及其状态。 详解见官网，格式为：</p>
<p>![image-20200831220953955](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831220953955.png)</p>
<h2 id="proc-partitions"><a href="#proc-partitions" class="headerlink" title="/proc/partitions"></a>/proc/partitions</h2><p>包含每个分区的主要和次要编号，以及1024字节块的数量和分区名称。</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831221336055.png" alt="image-20200831221336055" style="zoom:50%;" />

<h2 id="proc-scsi"><a href="#proc-scsi" class="headerlink" title="/proc/scsi"></a>/proc/scsi</h2><p>一个包含scsi中级伪文件和各种SCSI低级驱动程序目录的目录，其中包含该系统中每个SCSI主机的文件，所有这些文件都提供了SCSI IO子系统某些部分的状态。 这些文件包含ASCII结构，因此可通过cat（1）读取。</p>
<p>您还可以写入某些文件以重新配置子系统或打开或关闭某些功能。</p>
<h2 id="proc-scsi-scsi"><a href="#proc-scsi-scsi" class="headerlink" title="/proc/scsi/scsi"></a>/proc/scsi/scsi</h2><p>这是内核已知的所有SCSI设备的清单，该清单类似于启动期间看到的清单。 scsi当前仅支持add-single-device命令，该命令允许root用户将热插拔设备添加到已知设备列表中。命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;scsi add-single-device 1 0 5 0&#39; &gt; &#x2F;proc&#x2F;scsi&#x2F;scsi</span><br></pre></td></tr></table></figure>
<p>将导致主机scsi1在SCSI通道0上扫描ID 5 LUN 0上的设备。如果此地址上已经存在已知设备，或者该地址无效，则将返回错误。</p>
<h2 id="proc-self-1"><a href="#proc-self-1" class="headerlink" title="/proc/self"></a>/proc/self</h2><p>该目录引用访问/ proc文件系统的进程，并且与以相同进程的进程ID命名的/ proc目录相同。</p>
<h2 id="proc-slabinfo"><a href="#proc-slabinfo" class="headerlink" title="/proc/slabinfo"></a>/proc/slabinfo</h2><p>有关内核缓存的信息。See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/slabinfo.5.html">slabinfo(5)</a> for details.</p>
<p>Linux内核中的常用对象（buffer heads，inode，dentries等）具有自己的缓存。 文件/ proc / slabinfo提供有关这些缓存的统计信息。 以下（编辑后的）输出显示此文件内容的示例：</p>
<p>![image-20200831222353796](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831222353796.png)</p>
<h2 id="proc-stat"><a href="#proc-stat" class="headerlink" title="/proc/stat"></a>/proc/stat</h2><p>内核/系统统计信息。 因架构而异。 解释见官网，常见条目包括：</p>
<p>![image-20200831222913173](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831222913173.png)</p>
<h2 id="proc-swaps"><a href="#proc-swaps" class="headerlink" title="/proc/swaps"></a>/proc/swaps</h2><p>Swap areas in use.  See also <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/swapon.8.html">swapon(8)</a>.</p>
<p>![image-20200831223102174](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831223102174.png)</p>
<h2 id="proc-sys"><a href="#proc-sys" class="headerlink" title="/proc/sys"></a>/proc/sys</h2><p>该目录（自1.3.57开始出现）包含许多与内核变量相对应的文件和子目录。 可以使用/ proc文件系统以及（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/sysctl.2.html">sysctl（2）</a>)系统调用读取这些变量，有时可以对其进行修改。</p>
<h2 id="proc-sys-abi"><a href="#proc-sys-abi" class="headerlink" title="/proc/sys/abi"></a>/proc/sys/abi</h2><p>存有内核参数vsyscall32</p>
<h2 id="proc-sys-debug"><a href="#proc-sys-debug" class="headerlink" title="/proc/sys/debug"></a>/proc/sys/debug</h2><p>存有内核参数</p>
<h2 id="proc-sys-dev"><a href="#proc-sys-dev" class="headerlink" title="/proc/sys/dev"></a>/proc/sys/dev</h2><p>该目录包含特定于设备的信息，即内核参数（例如，dev / cdrom / info）。 在某些系统上，它可能为空。</p>
<h2 id="proc-sys-fs"><a href="#proc-sys-fs" class="headerlink" title="/proc/sys/fs"></a>/proc/sys/fs</h2><p>该目录包含与文件系统相关的内核变量的文件和子目录。</p>
<h2 id="proc-sys-fs-aio-max-nr-和-proc-sys-fs-aio-nr"><a href="#proc-sys-fs-aio-max-nr-和-proc-sys-fs-aio-nr" class="headerlink" title="/proc/sys/fs/aio-max-nr 和 /proc/sys/fs/aio-nr"></a>/proc/sys/fs/aio-max-nr 和 /proc/sys/fs/aio-nr</h2><p>aio-nr是<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/io_setup.2.html">io_setup（2）</a>调用为所有当前活动的AIO上下文指定的事件总数。 如果aio-nr达到aio-max-nr，则io_setup（2）将失败，并显示错误EAGAIN。 提高aio-max-nr不会导致任何内核数据结构的预分配或调整大小。</p>
<h2 id="proc-sys-fs-binfmt-misc"><a href="#proc-sys-fs-binfmt-misc" class="headerlink" title="/proc/sys/fs/binfmt_misc"></a>/proc/sys/fs/binfmt_misc</h2><p>可以在Linux内核源代码的Documentation / admin-guide / binfmt-misc.rst文件中找到该目录中的文档（或者在较早的内核中的Documentation / binfmt_misc.txt中）。</p>
<h2 id="proc-sys-fs-dentry-state"><a href="#proc-sys-fs-dentry-state" class="headerlink" title="/proc/sys/fs/dentry-state"></a>/proc/sys/fs/dentry-state</h2><p>该文件包含有关目录缓存（dcache）状态的信息。 该文件包含六个数字，nr_dentry，nr_unused，age_limit（以秒为单位的），want_pages（系统请求的页面）和两个虚拟值。详解见官网</p>
<img src="/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831224528887.png" alt="image-20200831224528887" style="zoom:50%;" />

<h2 id="proc-sys-fs-dir-notify-enable"><a href="#proc-sys-fs-dir-notify-enable" class="headerlink" title="/proc/sys/fs/dir-notify-enable"></a>/proc/sys/fs/dir-notify-enable</h2><p>该文件可用于在系统范围内禁用或启用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl（2）</a>中描述的dnotify接口。 该文件中的值0禁用接口，而值1启用接口。</p>
<p>dnotify：File and directory change notification</p>
<h2 id="proc-sys-fs-epoll"><a href="#proc-sys-fs-epoll" class="headerlink" title="/proc/sys/fs/epoll"></a>/proc/sys/fs/epoll</h2><p>该目录包含文件max_user_watches，该文件可用于限制epoll接口消耗的内核内存量。 有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll（7）</a>。</p>
<p>这指定了用户可以在系统上所有epoll实例之间注册的文件描述符总数的限制。 限制是每个真实用户ID。 每个注册文件描述符在32位内核上的成本约为90字节，在64位内核上的成本约为160字节。 当前，max_user_watches的默认值为可用低内存的1/25（4％）除以字节的注册成本。</p>
<h2 id="proc-sys-fs-file-max"><a href="#proc-sys-fs-file-max" class="headerlink" title="/proc/sys/fs/file-max"></a>/proc/sys/fs/file-max</h2><p>该文件定义了系统范围内所有进程的打开文件数限制。 遇到此限制时失败的系统调用将失败，并显示错误ENFILE。 （另请参阅<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit（2）</a>，进程可以使用它来设置每个进程可以打开的文件数的限制RLIMIT_NOFILE。）如果您在内核日志中收到很多有关用尽了的错误消息， 文件句柄（look for “VFS: file-max limit <number> reached”），请尝试增加此值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 100000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br></pre></td></tr></table></figure>
<p>特权进程（CAP_SYS_ADMIN）可以覆盖文件最大限制。</p>
<h2 id="proc-sys-fs-file-nr"><a href="#proc-sys-fs-file-nr" class="headerlink" title="/proc/sys/fs/file-nr"></a>/proc/sys/fs/file-nr</h2><p>该（只读）文件包含三个数字：分配的文件句柄数（即当前打开的文件数）； 空闲文件句柄的数量； 以及文件句柄的最大数量（即与/ proc / sys / fs / file-max相同的值）。 如果分配的文件句柄数量接近最大值，则应考虑增加最大值。 在Linux 2.6之前，内核分配的文件是动态处理的，但是并没有再次释放它们。 而是将免费文件句柄保留在列表中以进行重新分配。 “免费文件句柄”值指示该列表的大小。 大量的免费文件句柄表示打开文件句柄的使用已达到峰值。 从Linux 2.6开始，内核会释放释放的文件句柄，并且“空闲文件句柄”值始终为零。</p>
<p>![image-20200831225517736](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831225517736.png)</p>
<h2 id="proc-sys-fs-inode-nr"><a href="#proc-sys-fs-inode-nr" class="headerlink" title="/proc/sys/fs/inode-nr"></a>/proc/sys/fs/inode-nr</h2><p>该文件包含来自inode-state的前两个值。</p>
<h2 id="proc-sys-fs-inode-state"><a href="#proc-sys-fs-inode-state" class="headerlink" title="/proc/sys/fs/inode-state"></a>/proc/sys/fs/inode-state</h2><p>该文件包含七个数字: nr_inodes, nr_free_inodes, preshrink, and four dummy values (always zero)</p>
<p>nr_inodes是系统已分配的索引节点数。<br>nr_free_inodes表示空闲索引节点的数量。<br>当nr_inodes&gt; inode-max并且系统需要修剪inode列表而不是分配更多资源时，preshrink不为零。 从Linux 2.4开始，此字段为伪值（始终为零）。</p>
<p>![image-20200831225737688](/Users/shenshawn/Library/Application Support/typora-user-images/image-20200831225737688.png)</p>
<h2 id="proc-sys-fs-inotify"><a href="#proc-sys-fs-inotify" class="headerlink" title="/proc/sys/fs/inotify"></a>/proc/sys/fs/inotify</h2><p>该目录包含文件max_queued_events，max_user_instances和max_user_watches，可用于限制inotify接口消耗的内核内存量。 有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/inotify.7.html">inotify（7）</a>。</p>
<p>notify API提供了一种监视文件系统事件的机制。 Inotify可用于监视单个文件或目录。 监视目录时，inotify将返回目录本身以及目录中文件的事件。</p>
<h2 id="proc-sys-fs-lease-break-time"><a href="#proc-sys-fs-lease-break-time" class="headerlink" title="/proc/sys/fs/lease-break-time"></a>/proc/sys/fs/lease-break-time</h2><p>该文件指定了内核向持有文件租约的进程（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl（2）</a>）授予该进程的信号后，通知该进程另一个进程正在等待打开该文件的宽限期。 如果租约持有人在此宽限期内没有删除或降级租约，则内核会强行中断租约。</p>
<h2 id="proc-sys-fs-leases-enable"><a href="#proc-sys-fs-leases-enable" class="headerlink" title="/proc/sys/fs/leases-enable"></a>/proc/sys/fs/leases-enable</h2><p>此文件可用于在系统范围内启用或禁用文件租约（fcntl（2））。 如果此文件包含值0，则禁用租约。 非零值将启用租约。</p>
<h2 id="proc-sys-fs-mount-max"><a href="#proc-sys-fs-mount-max" class="headerlink" title="/proc/sys/fs/mount-max"></a>/proc/sys/fs/mount-max</h2><p>该文件中的值指定mount namespace中可能存在的最大mount数量。 该文件的默认值为100,000。</p>
<h2 id="proc-sys-fs-mqueue"><a href="#proc-sys-fs-mqueue" class="headerlink" title="/proc/sys/fs/mqueue"></a>/proc/sys/fs/mqueue</h2><p>此目录包含文件msg_max，msgsize_max和queues_max，控制POSIX消息队列使用的资源。 有关详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/mq_overview.7.html">mq_overview</a></p>
<h2 id="proc-sys-fs-nr-open"><a href="#proc-sys-fs-nr-open" class="headerlink" title="/proc/sys/fs/nr_open"></a>/proc/sys/fs/nr_open</h2><p>该文件对可以将RLIMIT_NOFILE资源限制提高到的值施加上限（请参见getrlimit（2））。 此上限适用于无特权和特权进程。 该文件的默认值为1048576。（在Linux 2.6.25之前，RLIMIT_NOFILE的上限被硬编码为相同的值。）</p>
<h2 id="proc-sys-fs-overflowgid-and-proc-sys-fs-overflowuid"><a href="#proc-sys-fs-overflowgid-and-proc-sys-fs-overflowuid" class="headerlink" title="/proc/sys/fs/overflowgid and /proc/sys/fs/overflowuid"></a>/proc/sys/fs/overflowgid and /proc/sys/fs/overflowuid</h2><p>这些文件使您可以更改固定UID和GID的值。 默认值为65534。某些文件系统仅支持16位UID和GID，尽管在Linux中UID和GID为32位。 如果在启用写操作的情况下挂载了这些文件系统之一，则任何超过65535的UID或GID都会在写入磁盘之前转换为溢出值。</p>
<h2 id="proc-sys-fs-pipe-max-size"><a href="#proc-sys-fs-pipe-max-size" class="headerlink" title="/proc/sys/fs/pipe-max-size"></a>/proc/sys/fs/pipe-max-size</h2><p>管道（pipe）和FIFO（也称为命名管道）提供了单向进程间通信通道。 管道具有读取端和写入端。 可以从管道的读取端读取写入管道的写入端的数据。</p>
<p>使用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe（2）</a>创建一个管道，该管道创建一个新管道并返回两个文件描述符，一个文件描述符指向该管道的读取端，另一个文件描述符指向写入端。 管道可用于在相关进程之间创建通信通道； 有关示例，请参见pipe（2）。</p>
<p>FIFO（先进先出的缩写）在文件系统中具有名称（使用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/mkfifo.3.html">mkfifo（3）</a>创建），并使用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/open.2.html">open（2）</a>打开。 假设文件权限允许，则任何进程都可以打开FIFO。 使用O_RDONLY标志打开读取端； 使用O_WRONLY标志打开写端。 有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/fifo.7.html">fifo（7）</a>。 注意：尽管FIFO在文件系统中具有路径名，但是FIFO上的I / O不涉及对基础设备的操作。</p>
<p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pipe.7.html">pipe(7)</a></p>
<p>没有CAP_SYS_RESOURCE功能的用户可以设置的单个管道的最大大小（以字节为单位）。 分配给该文件的值可以向上舍入，以反映为方便实施而实际使用的值。 要确定上舍入的值，请在为其分配值后显示此文件的内容。</p>
<p>该文件的默认值为1048576（1 MiB）。 可以分配给该文件的最小值是系统页面大小。 尝试将限制设置为小于页面大小会导致write（2）失败，并显示错误EINVAL。</p>
<p>从Linux 4.9开始，此文件上的值还充当新管道或新打开的FIFO的默认容量的上限。</p>
<h2 id="proc-sys-fs-pipe-user-pages-hard"><a href="#proc-sys-fs-pipe-user-pages-hard" class="headerlink" title="/proc/sys/fs/pipe-user-pages-hard"></a>/proc/sys/fs/pipe-user-pages-hard</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pipe.7.html">pipe(7)</a></p>
<p>由单个非特权用户（即既不具有CAP_SYS_RESOURCE也不具有CAP_SYS_ADMIN功能的用户）创建或设置的所有管道的总大小（以页为单位）的硬性限制。 只要为此用户分配给管道缓冲区的页面总数达到此限制，就将拒绝创建新管道的尝试，并且拒绝增加管道容量的尝试。</p>
<p>当此限制的值为零（默认值）时，不应用硬限制。</p>
<h2 id="proc-sys-fs-pipe-user-pages-soft"><a href="#proc-sys-fs-pipe-user-pages-soft" class="headerlink" title="/proc/sys/fs/pipe-user-pages-soft"></a>/proc/sys/fs/pipe-user-pages-soft</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pipe.7.html">pipe(7)</a></p>
<p>由单个非特权用户（即既没有CAP_SYS_RESOURCE也没有CAP_SYS_ADMIN功能的用户）创建或设置的所有管道的总大小（以页为单位）的软限制。 只要为此用户分配给管道缓冲区的页面总数达到此限制，用户创建的各个管道将被限制为一页，并且增加管道容量的尝试将被拒绝。</p>
<p>当此限制的值为零时，不应用软限制。 该文件的默认值为16384，它允许创建多达1024个具有默认容量的管道。</p>
<h2 id="proc-sys-fs-protected-hardlinks"><a href="#proc-sys-fs-protected-hardlinks" class="headerlink" title="/proc/sys/fs/protected_hardlinks"></a>/proc/sys/fs/protected_hardlinks</h2><p>当此文件中的值为0时，硬链接的创建没有任何限制（即，这是Linux 3.6之前的历史行为）。 当此文件中的值为1时，只有满足以下条件之一，才可以创建到目标文件的硬链接：</p>
<ul>
<li>调用过程在其用户名称空间中具有CAP_FOWNER功能，而文件UID在名称空间中具有映射。</li>
</ul>
<ul>
<li>创建链接的进程的文件系统UID与目标文件的所有者（UID）匹配（如凭据（7）中所述，进程的文件系统UID通常与其有效UID相同）。</li>
</ul>
<ul>
<li>以下所有条件均成立：<br>目标是常规文件；<br>目标文件未启用其设置用户ID模式位；<br>目标文件没有同时启用其set-group-ID和group-executable模式位；和<br>调用方具有读写目标文件的权限（通过文件的权限掩码或具有适当功能的权限）。</li>
</ul>
<p>该文件的默认值为0。将该值设置为1可防止长期存在的安全问题，这些问题是由基于硬链接的检查时间，使用时间竞争引起的，这种情况在全局可写目录中最常见的是 /tmp。利用此缺陷的常见方法是在遵循给定的硬链接时（即，根进程遵循由另一个用户创建的硬链接）跨越特权边界。此外，在没有单独分区的系统上，这可以防止未经授权的用户“固定”易受攻击的set-user-ID和set-group-ID文件，以防管理员升级或链接到特殊文件。</p>
<h2 id="proc-sys-fs-protected-symlinks"><a href="#proc-sys-fs-protected-symlinks" class="headerlink" title="/proc/sys/fs/protected_symlinks"></a>/proc/sys/fs/protected_symlinks</h2><p>当此文件中的值为0时，对以下符号链接没有任何限制（即，这是Linux 3.6之前的历史行为）。 当此文件中的值为1时，仅在以下情况下才创建符号链接：</p>
<p>*链接后的进程的文件系统UID与符号链接的所有者（UID）匹配（如<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/credentials.7.html">credentials(7)</a>中所述，进程的文件系统UID通常与其有效UID相同）；</p>
<p>*链接不指向全局可写的目录中</p>
<p>*符号链接及其父目录具有相同的所有者（UID）</p>
<p>由于上述限制，未能遵循符号链接的系统调用将在errno中返回错误EACCES。</p>
<p>该文件的默认值为0。将值设置为1可以避免长期访问访问符号链接时基于检查时间和使用时间竞争的安全问题。</p>
<h2 id="proc-sys-fs-suid-dumpable"><a href="#proc-sys-fs-suid-dumpable" class="headerlink" title="/proc/sys/fs/suid_dumpable"></a>/proc/sys/fs/suid_dumpable</h2><p>在<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/prctl.2.html">prctl（2）</a>中描述的情况下，此文件中的值分配给进程的“可转储（dumpable）”标志。 实际上，此文件中的值确定是否为设置用户ID或其他受 保护/污染 的二进制文件生成核心转储文件。 如上所述，“可转储”设置还会影响进程的/ proc / [pid]目录中文件的所有权。</p>
<p>可以指定三个不同的整数值：</p>
<p>0 (default)</p>
<p>这提供了传统的（Linux 2.6.13之前的）行为。 对于更改了凭据（通过调用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/seteuid.2.html">seteuid（2）</a>，<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/setgid.2.html">setgid（2）</a>或类似的代码，或者通过执行set-user-ID或set-group-ID程序）或没有启用读取权限的二进制文件的进程，不会生成核心转储 。</p>
<p>1(“debug”)</p>
<p>所有进程都尽可能转储核心。 （在core（5）中描述了为什么进程仍不能转储core的原因。）core dump由转储过程的文件系统用户ID拥有，并且不应用安全性。 这仅用于系统调试情况：此模式是不安全的，因为它允许无特权的用户检查特权进程的内存内容。</p>
<p>2 (“suidsafe”)</p>
<p>通常不会转储的任何二进制文件（请参见上面的“ 0”）都只能由root用户读取。 这允许用户删除核心转储文件，但不能读取它。 出于安全原因，在此模式下核心转储不会覆盖彼此或其他文件。 当管理员试图在正常环境中调试问题时，此模式是合适的。</p>
<p>此外，从Linux 3.6开始，/ proc / sys / kernel / core_pattern必须是绝对路径名或管道命令，如<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/core.5.html">core（5）</a>中所述。 如果core_pattern不遵循这些规则，则会将警告写入内核日志，并且不会生成任何内核转储。</p>
<p>有关进程的“可转储”设置对ptrace访问模式检查的影响的详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace（2）</a>。</p>
<h2 id="proc-sys-fs-super-max"><a href="#proc-sys-fs-super-max" class="headerlink" title="/proc/sys/fs/super-max"></a>/proc/sys/fs/super-max</h2><p>该文件控制超级块的最大数量，从而控制内核可以具有的已挂载文件系统的最大数量。 如果您需要装载的文件系统超出super-max中当前值所允许的数量，则只需增加super-max。</p>
<p>此文件不存在</p>
<h2 id="proc-sys-kernel"><a href="#proc-sys-kernel" class="headerlink" title="/proc/sys/kernel"></a>/proc/sys/kernel</h2><p>该目录包含控制一系列内核参数的文件，如下所述。</p>
<h2 id="proc-sys-kernel-acct"><a href="#proc-sys-kernel-acct" class="headerlink" title="/proc/sys/kernel/acct"></a>/proc/sys/kernel/acct</h2><p>该文件包含三个数字：高水位/highwater，低水位/lowwater, 和频率/frequency。 如果启用了BSD风格的进程 统计/accounting ，则这些值将控制其行为。 如果日志所在的文件系统上的free空间低于低水位百分比，则accounting将暂停。 如果free空间超过高水位百分比，则accounting将恢复。 频率确定内核检查可用空间量的频率（值以秒为单位）。 默认值为4、2和30。也就是说，如果2％或更少的空间free，则暂停accounting； 如果有4％或更多的free空间，则恢复accounting； 考虑有关30秒内有效的free空间量的信息。</p>
<h2 id="proc-sys-kernel-auto-msgmni"><a href="#proc-sys-kernel-auto-msgmni" class="headerlink" title="/proc/sys/kernel/auto_msgmni"></a>/proc/sys/kernel/auto_msgmni</h2><p>从Linux 2.6.27到3.18，此文件用于控制添加/删除内存或创建/删除IPC名称空间时/ proc / sys / kernel / msgmni中值的重新计算。 在该文件中回显“ 1”将启用msgmni自动重新计算（并根据当前的可用内存量和IPC名称空间的数量触发msgmni的重新计算）。 回显“ 0”将禁用自动重新计算。 （如果将值显式分配给/ proc / sys / kernel / msgmni，则也会禁用自动重新计算。）auto_msgmni的默认值为1。</p>
<p>从Linux 3.19开始，此文件的内容无效（因为msgmni的默认值接近最大可能值），并且从此文件读取的值始终返回值“ 0”。</p>
<h2 id="proc-sys-kernel-cap-last-cap"><a href="#proc-sys-kernel-cap-last-cap" class="headerlink" title="/proc/sys/kernel/cap_last_cap"></a>/proc/sys/kernel/cap_last_cap</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities(7)</a></p>
<p>为了执行权限检查，传统的UNIX实现将进程分为两类：特权进程（其有效用户ID为0，称为超级用户或root）和非特权进程（其有效UID为非零）。 特权进程绕过所有内核权限检查，而无特权的进程则根据进程的凭据（通常是：有效的UID，有效的GID和补充组列表）接受完全的权限检查。</p>
<p>从内核2.2开始，Linux将传统上与超级用户相关联的特权划分为不同的单元，称为功能/capabilities，可以独立地启用和禁用这些功能。 功能是每个线程的属性。</p>
<p>从Linux 3.2开始，文件/ proc / sys / kernel / cap_last_cap公开了正在运行的内核所支持的最高capability的数值。 这可用于确定功能集中可能设置的最高位。</p>
<h2 id="proc-sys-kernel-core-pattern"><a href="#proc-sys-kernel-core-pattern" class="headerlink" title="/proc/sys/kernel/core_pattern"></a>/proc/sys/kernel/core_pattern</h2><p>某些信号的默认操作是使进程终止并产生一个核心转储文件，该文件包含终止时进程内存的映像。 该映像可以在调试器（例如<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/gdb.1.html">gdb（1）</a>）中使用，以检查程序终止时的状态。 导致进程转储内核的信号列表可以在<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/signal.7.html">signal（7）</a>中找到。</p>
<p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>.</p>
<p>默认情况下，核心转储文件名为core，但是/ proc / sys / kernel / core_pattern文件（自Linux 2.6和2.4.21起）可以设置为定义用于命名核心转储文件的模板。 模板可以包含％说明符，当创建核心文件时，这些说明符将由以下值替换：（见官网）</p>
<h2 id="proc-sys-kernel-core-pipe-limit"><a href="#proc-sys-kernel-core-pipe-limit" class="headerlink" title="/proc/sys/kernel/core_pipe_limit"></a>/proc/sys/kernel/core_pipe_limit</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>.</p>
<p>当通过管道将核心转储收集到用户空间程序时，收集程序从该进程的/ proc / [pid]目录中收集有关崩溃进程的数据可能很有用。为了安全地执行此操作，内核必须等待收集核心转储的程序退出，以免过早删除崩溃进程的/ proc / [pid]文件。反过来，这可能导致行为不当的收集程序通过根本不退出就可以阻止崩溃进程的收集。</p>
<p>从Linux 2.6.32开始，/ proc / sys / kernel / core_pipe_limit可用于防御这种可能性。该文件中的值定义可以并行将多少个并发的崩溃进程通过管道传递给用户空间程序。如果超过此值，则在该日志中会记录高于该值的那些崩溃进程，并跳过其核心转储。</p>
<p>该文件中的值为0是特殊的。它表示可以并行捕获无限的进程，但是不会等待（即，不能保证收集程序可以访问/ proc / <crashing-PID>）。该文件的默认值为0。</p>
<h2 id="proc-sys-kernel-core-uses-pid"><a href="#proc-sys-kernel-core-uses-pid" class="headerlink" title="/proc/sys/kernel/core_uses_pid"></a>/proc/sys/kernel/core_uses_pid</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>.</p>
<p>从2.4版开始，Linux还提供了一种更原始的方法来控制核心转储文件的名称。 如果/ proc / sys / kernel / core_uses_pid文件包含值0，则将核心转储文件简称为core。 如果此文件包含非零值，则核心转储文件将以进程core.PID的名称包含进程ID。</p>
<h2 id="proc-sys-kernel-ctrl-alt-del"><a href="#proc-sys-kernel-ctrl-alt-del" class="headerlink" title="/proc/sys/kernel/ctrl-alt-del"></a>/proc/sys/kernel/ctrl-alt-del</h2><p>该文件控制键盘上Ctrl-Alt-Del的处理。 当此文件中的值为0时，将捕获Ctrl-Alt-Del并将其发送到init（1）程序以进行正常重启。 当该值大于零时，Linux对Vulcan Nerve Pinch（tm）的反应将是立即重启，甚至不同步其脏缓冲区。 注意：当某个程序（例如dosemu）的键盘处于“raw”模式时，在到达内核tty层之前，该程序会拦截ctrl-alt-del，由程序决定如何处理 它。</p>
<h2 id="proc-sys-kernel-dmesg-restrict"><a href="#proc-sys-kernel-dmesg-restrict" class="headerlink" title="/proc/sys/kernel/dmesg_restrict"></a>/proc/sys/kernel/dmesg_restrict</h2><p>该文件中的值确定哪些人可以看到内核syslog内容。 该文件中的0值没有任何限制。 如果值为1，则只有特权用户才能读取内核syslog。 （有关更多详细信息，请参见syslog（2）。）从Linux 3.4开始，只有具有CAP_SYS_ADMIN功能的用户才能更改此文件中的值。</p>
<h2 id="proc-sys-kernel-domainname-和-proc-sys-kernel-hostname"><a href="#proc-sys-kernel-domainname-和-proc-sys-kernel-hostname" class="headerlink" title="/proc/sys/kernel/domainname 和 /proc/sys/kernel/hostname"></a>/proc/sys/kernel/domainname 和 /proc/sys/kernel/hostname</h2><p>可用于以与命令<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/domainname.1.html">domainname（1）</a>和<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/hostname.1.html">hostname（1）</a>完全相同的方式来设置NIS / YP域名和您的机器的主机名，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃echo&#39;darkstar&#39;&gt; &#x2F; proc &#x2F; sys &#x2F; kernel &#x2F; hostname</span><br><span class="line">＃echo&#39;mydomain&#39;&gt; &#x2F; proc &#x2F; sys &#x2F; kernel &#x2F; domainname</span><br></pre></td></tr></table></figure>
<p>与下述命令具有相同的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃hostname &#39;darkstar&#39;</span><br><span class="line">＃domainname &quot;mydomain&quot;</span><br></pre></td></tr></table></figure>
<p>但是请注意，经典的darkstar.frop.org具有主机名“ darkstar”和DNS（Internet域名服务器）域名“ frop.org”，请勿与NIS（网络信息服务）或YP（黄页）混淆。 ）域名。 这两个域名通常是不同的。 有关详细讨论，请参见hostname（1）手册页。</p>
<h2 id="proc-sys-kernel-hotplug"><a href="#proc-sys-kernel-hotplug" class="headerlink" title="/proc/sys/kernel/hotplug"></a>/proc/sys/kernel/hotplug</h2><p>该文件包含热插拔策略代理的路径名。 该文件的默认值为/ sbin / hotplug。</p>
<h2 id="proc-sys-kernel-keys"><a href="#proc-sys-kernel-keys" class="headerlink" title="/proc/sys/kernel/keys/*"></a>/proc/sys/kernel/keys/*</h2><p>该目录包含各种文件，这些文件定义了密钥管理工具的参数和限制。 这些文件在<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/keyrings.7.html">keyrings（7）</a>中进行了描述。</p>
<p>Linux密钥管理工具主要是各种内核组件在内核中保留或缓存安全数据，身份验证密钥，加密密钥和其他数据的一种方式。</p>
<p>提供系统调用接口，以便用户空间程序可以管理那些对象，也可以将其用于自己的目的。 请参阅add_key（2），request_key（2）和keyctl（2）。</p>
<p>提供了一个库和一些用户空间实用程序以允许访问该设施。 有关更多信息，请参见keyctl（1），keyctl（3）和keyutils（7）。</p>
<h2 id="proc-sys-kernel-kptr-restrict"><a href="#proc-sys-kernel-kptr-restrict" class="headerlink" title="/proc/sys/kernel/kptr_restrict"></a>/proc/sys/kernel/kptr_restrict</h2><p>该文件中的值确定是否通过/ proc文件和其他接口公开内核地址。 该文件中的0值没有任何限制。 如果值为1，则除非用户具有CAP_SYSLOG功能，否则使用％pK格式说明符打印的内核指针将被替换为零。 如果值为2，则无论用户的能力如何，使用％pK格式说明符打印的内核指针都将替换为零。 该文件的初始默认值为1，但在Linux 2.6.39中将默认值更改为0。从Linux 3.4开始，只有具有CAP_SYS_ADMIN功能的用户才能更改此文件中的值。</p>
<h2 id="proc-sys-kernel-modprobe"><a href="#proc-sys-kernel-modprobe" class="headerlink" title="/proc/sys/kernel/modprobe"></a>/proc/sys/kernel/modprobe</h2><p>该文件包含内核模块加载器的路径名。 默认值为/ sbin / modprobe。 仅当启用了CONFIG_MODULES（在Linux 2.6.26和更早版本中为CONFIG_KMOD）选项构建内核时，该文件才存在。 它由Linux内核源文件Documentation / kmod.txt（仅在内核2.4及更早版本中提供）描述。</p>
<h2 id="proc-sys-kernel-modules-disabled"><a href="#proc-sys-kernel-modules-disabled" class="headerlink" title="/proc/sys/kernel/modules_disabled"></a>/proc/sys/kernel/modules_disabled</h2><p>一个切换值，指示是否允许在其他模块化内核中加载模块。 此切换默认为关闭（0），但可以设置为true（1）。 一旦为true，就无法加载或卸载模块，并且不能将切换设置回false。 仅当内核在启用CONFIG_MODULES选项的情况下构建时，该文件才存在。</p>
<h2 id="proc-sys-kernel-msgmax"><a href="#proc-sys-kernel-msgmax" class="headerlink" title="/proc/sys/kernel/msgmax"></a>/proc/sys/kernel/msgmax</h2><p>该文件定义了系统范围的限制，该限制指定写入System V消息队列的单个消息中的最大字节数。</p>
<h2 id="proc-sys-kernel-msgmni"><a href="#proc-sys-kernel-msgmni" class="headerlink" title="/proc/sys/kernel/msgmni"></a>/proc/sys/kernel/msgmni</h2><p>该文件定义了系统范围内消息队列标识符的数量限制。 另请参见/ proc / sys / kernel / auto_msgmni。</p>
<h2 id="proc-sys-kernel-msgmnb"><a href="#proc-sys-kernel-msgmnb" class="headerlink" title="/proc/sys/kernel/msgmnb"></a>/proc/sys/kernel/msgmnb</h2><p>该文件定义了系统范围的参数，该参数用于初始化随后创建的消息队列的msg_qbytes设置。 msg_qbytes设置指定可以写入消息队列的最大字节数。</p>
<h2 id="proc-sys-kernel-ngroups-max"><a href="#proc-sys-kernel-ngroups-max" class="headerlink" title="/proc/sys/kernel/ngroups_max"></a>/proc/sys/kernel/ngroups_max</h2><p>这是一个只读文件，显示进程的组成员资格数量的上限。</p>
<h2 id="proc-sys-kernel-ns-last-pid-since-Linux-3-3"><a href="#proc-sys-kernel-ns-last-pid-since-Linux-3-3" class="headerlink" title="/proc/sys/kernel/ns_last_pid (since Linux 3.3)"></a>/proc/sys/kernel/ns_last_pid (since Linux 3.3)</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pid_namespaces.7.html">pid_namespaces(7)</a>.</p>
<p>该文件（每个PID名称空间已虚拟化）显示此PID名称空间中分配的最后一个PID。 分配下一个PID时，内核将搜索大于该值的最低未分配PID，随后读取此文件时，它将显示该PID。</p>
<p>该文件可由拥有PID名称空间的用户名称空间内具有CAP_SYS_ADMIN功能的进程写入。 这样就可以确定分配给在此PID名称空间内创建的下一个进程的PID。</p>
<h2 id="proc-sys-kernel-ostype-和-proc-sys-kernel-osrelease"><a href="#proc-sys-kernel-ostype-和-proc-sys-kernel-osrelease" class="headerlink" title="/proc/sys/kernel/ostype 和 /proc/sys/kernel/osrelease"></a>/proc/sys/kernel/ostype 和 /proc/sys/kernel/osrelease</h2><p>  这些文件提供/ proc / version的子字符串</p>
<h2 id="proc-sys-kernel-overflowgid-和-proc-sys-kernel-overflowuid"><a href="#proc-sys-kernel-overflowgid-和-proc-sys-kernel-overflowuid" class="headerlink" title="/proc/sys/kernel/overflowgid 和 /proc/sys/kernel/overflowuid"></a>/proc/sys/kernel/overflowgid 和 /proc/sys/kernel/overflowuid</h2><p>These files duplicate the files /proc/sys/fs/overflowgid and /proc/sys/fs/overflowuid.</p>
<h2 id="proc-sys-kernel-panic"><a href="#proc-sys-kernel-panic" class="headerlink" title="/proc/sys/kernel/panic"></a>/proc/sys/kernel/panic</h2><p>该文件提供对内核变量panic_timeout的读/写访问权限。 如果为零，内核将在 紧急/panic 情况下循环； 如果非零，则表示内核应在此秒数后自动重新引导。 使用软件watchdog device driver时，建议设置为60。</p>
<h2 id="proc-sys-kernel-panic-on-oops"><a href="#proc-sys-kernel-panic-on-oops" class="headerlink" title="/proc/sys/kernel/panic_on_oops"></a>/proc/sys/kernel/panic_on_oops</h2><p>当遇到oops或BUG时，此文件控制内核的行为。 如果此文件包含0，则系统尝试继续操作。 如果它包含1，则系统会延迟几秒钟（给klogd时间记录oops输出），然后出现panic 情况。 如果/ proc / sys / kernel / panic文件也不为零，则计算机将重新启动。</p>
<h2 id="proc-sys-kernel-pid-max"><a href="#proc-sys-kernel-pid-max" class="headerlink" title="/proc/sys/kernel/pid_max"></a>/proc/sys/kernel/pid_max</h2><p>该文件指定PID环绕的值（即此文件中的值比最大PID大1）。大于此值的PID不分配; 因此，此文件中的值还充当系统范围内进程和线程总数的限制。 该文件的默认值32768导致PID范围与早期内核相同。 在32位平台上，pid_max的最大值为32768。 在64位系统上，可以将pid_max设置为最大2 ^ 22的任何值（PID_MAX_LIMIT，大约为400万）。</p>
<h2 id="proc-sys-kernel-printk"><a href="#proc-sys-kernel-printk" class="headerlink" title="/proc/sys/kernel/printk"></a>/proc/sys/kernel/printk</h2><p>syslog，klogctl —— 读取和/或清除内核消息环形缓冲区； 设置console_loglevel</p>
<p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/syslog.2.html">syslog(2)</a>.</p>
<p>/ proc / sys / kernel / printk是一个可写文件，其中包含四个整数值，这些值会在打印或记录错误消息时影响内核printk（）的行为。详情见官网</p>
<h2 id="proc-sys-kernel-pty"><a href="#proc-sys-kernel-pty" class="headerlink" title="/proc/sys/kernel/pty"></a>/proc/sys/kernel/pty</h2><p>该目录包含两个与系统上的UNIX 98伪终端（请参阅<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man4/pts.4.html">pts（4）</a>）数量有关的文件。</p>
<h2 id="proc-sys-kernel-pty-max"><a href="#proc-sys-kernel-pty-max" class="headerlink" title="/proc/sys/kernel/pty/max"></a>/proc/sys/kernel/pty/max</h2><p> 此文件定义伪终端的最大数量。</p>
<h2 id="proc-sys-kernel-pty-nr"><a href="#proc-sys-kernel-pty-nr" class="headerlink" title="/proc/sys/kernel/pty/nr"></a>/proc/sys/kernel/pty/nr</h2><p>该只读文件指示当前正在使用多少个伪终端。</p>
<h2 id="proc-sys-kernel-random"><a href="#proc-sys-kernel-random" class="headerlink" title="/proc/sys/kernel/random"></a>/proc/sys/kernel/random</h2><p>该目录包含各种参数，这些参数控制文件/ dev / random的操作。 有关更多信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man4/random.4.html">random（4）</a>。</p>
<h2 id="proc-sys-kernel-random-uuid"><a href="#proc-sys-kernel-random-uuid" class="headerlink" title="/proc/sys/kernel/random/uuid"></a>/proc/sys/kernel/random/uuid</h2><p>从此只读文件中进行的每次读取都将以标准UUID格式的字符串形式返回随机生成的128位UUID。</p>
<h2 id="proc-sys-kernel-randomize-va-space"><a href="#proc-sys-kernel-randomize-va-space" class="headerlink" title="/proc/sys/kernel/randomize_va_space"></a>/proc/sys/kernel/randomize_va_space</h2><p>从该只读文件中进行的每次读取都将返回一个随机生成的128位UUID，作为字符串iSelect系统的地址空间布局随机化（ASLR）策略（在支持ASLR的体系结构上）。 此文件支持三个值：</p>
<p>0关闭ASLR。 对于不支持ASLR的体系结构，以及使用norandmaps参数引导内核时，这是默认设置。</p>
<p>1使mmap（2）分配的地址，堆栈和VDSO页面随机化。 除其他外，这意味着共享库将在随机地址处加载。 PIE链接的二进制文件的文本段也将加载到随机地址。 如果内核是使用CONFIG_COMPAT_BRK配置的，则此值为默认值</p>
<p>2（自Linux 2.6.25开始）还支持堆随机化。 如果未使用标准UUID格式CONFIG_COMPAT_BRK.n配置内核，则此值为默认值。</p>
<h2 id="proc-sys-kernel-real-root-dev"><a href="#proc-sys-kernel-real-root-dev" class="headerlink" title="/proc/sys/kernel/real-root-dev"></a>/proc/sys/kernel/real-root-dev</h2><p>该文件记录在Linux内核源文件Documentation / admin-guide / initrd.rst（或Linux 4.10之前的Documentation / initrd.txt）中。</p>
<h2 id="proc-pid-sched-autogroup-enabled"><a href="#proc-pid-sched-autogroup-enabled" class="headerlink" title="/proc/[pid]/sched_autogroup_enabled"></a>/proc/[pid]/sched_autogroup_enabled</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7)</a>.</p>
<h2 id="proc-sys-kernel-sched-child-runs-first"><a href="#proc-sys-kernel-sched-child-runs-first" class="headerlink" title="/proc/sys/kernel/sched_child_runs_first"></a>/proc/sys/kernel/sched_child_runs_first</h2><p>如果此文件包含零值，则在fork（2）之后，首先在CPU上调度父对象。 如果文件包含非零值，则首先在CPU上调度子项。 （当然，在多处理器系统上，父级和子级都可以立即在CPU上进行调度。）</p>
<h2 id="proc-sys-kernel-sched-rr-timeslice-ms"><a href="#proc-sys-kernel-sched-rr-timeslice-ms" class="headerlink" title="/proc/sys/kernel/sched_rr_timeslice_ms"></a>/proc/sys/kernel/sched_rr_timeslice_ms</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/sched_rr_get_interval.2.html">sched_rr_get_interval(2)</a>.</p>
<p>Linux 3.9添加了用于调整（和查看）SCHED_RR quantum的新机制：/ proc / sys / kernel / sched_rr_timeslice_ms文件将quantum公开为毫秒值（默认值为100）。向该文件写入0会将quantum重置为默认值。</p>
<h2 id="proc-sys-kernel-sched-rt-period-us"><a href="#proc-sys-kernel-sched-rt-period-us" class="headerlink" title="/proc/sys/kernel/sched_rt_period_us"></a>/proc/sys/kernel/sched_rt_period_us</h2><p> See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7)</a>.</p>
<p>该文件指定的调度周期等于100％CPU带宽。 该文件中的值的范围可以从1到INT_MAX，给出的操作范围是1微秒到35分钟左右。 该文件的默认值为1,000,000（1秒）。</p>
<h2 id="proc-sys-kernel-sched-rt-runtime-us"><a href="#proc-sys-kernel-sched-rt-runtime-us" class="headerlink" title="/proc/sys/kernel/sched_rt_runtime_us"></a>/proc/sys/kernel/sched_rt_runtime_us</h2><p> See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7)</a>.</p>
<p>该文件中的值指定系统上所有实时和截止时间计划的进程可以使用多少“period”时间。 该文件中的值的范围是-1至INT_MAX-1。 指定-1将使运行时间与时间段相同； 也就是说，没有为非实时进程预留CPU时间（这是内核2.6.25之前的Linux行为）。 此文件中的默认值为950,000（0.95秒），这意味着5％的CPU时间被保留用于不在实时或截止时间调度策略下运行的进程。</p>
<h2 id="proc-sys-kernel-seccomp"><a href="#proc-sys-kernel-seccomp" class="headerlink" title="/proc/sys/kernel/seccomp"></a>/proc/sys/kernel/seccomp</h2><p>该目录提供了其他seccomp信息和配置。 有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp（2）</a>。</p>
<p>seccomp:在进程的安全计算状态下运行</p>
<h2 id="proc-sys-kernel-sem"><a href="#proc-sys-kernel-sem" class="headerlink" title="/proc/sys/kernel/sem"></a>/proc/sys/kernel/sem</h2><p>该文件包含4个数字，用于定义System V IPC信号量的限制。 这些字段的顺序为：</p>
<p>SEMMSL 每个信号量集的最大信号量。</p>
<p>SEMMNS 所有信号量集中的系统范围内的信号量数量限制。</p>
<p>SEMOPM <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/semop.2.html">SEMOP（2）</a>调用中可以指定的最大操作数。</p>
<p>SEMMNI 信号标识符最大数量的系统范围限制。</p>
<h2 id="proc-sys-kernel-shm-rmid-forced"><a href="#proc-sys-kernel-shm-rmid-forced" class="headerlink" title="/proc/sys/kernel/shm_rmid_forced"></a>/proc/sys/kernel/shm_rmid_forced</h2><p>如果此文件设置为1，则在附加的进程数降至零时，所有System V共享内存段都将被标记为销毁；换句话说，不再可能创建独立于任何附加进程而存在的共享内存段。</p>
<p>效果就像在所有现有段以及将来创建的所有段上执行<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/shmctl.2.html">shmctl（2）</a>IPC_RMID一样（直到将此文件重置为0）。请注意，当此文件设置为1时，没有进程附加的现有段将立即被销毁。设置此选项还将销毁用shmget（2）创建的，和进程终止后创建但从未附加的段。</p>
<p>将此文件设置为1可提供一种方法，以确保至少在一个进程的资源使用情况和资源限制（请参阅getrlimit（2）中的RLIMIT_AS描述）中对所有System V共享内存段进行计数。</p>
<p>因为将此文件设置为1会产生非标准行为，并且还可能破坏现有应用程序，所以此文件中的默认值为0。仅当您对使用System V的应用程序的语义有很好的了解后，才将该文件设置为1。</p>
<h2 id="proc-sys-kernel-shmall"><a href="#proc-sys-kernel-shmall" class="headerlink" title="/proc/sys/kernel/shmall"></a>/proc/sys/kernel/shmall</h2><p>该文件包含系统范围内System V共享内存的总页数限制。</p>
<h2 id="proc-sys-kernel-shmmax"><a href="#proc-sys-kernel-shmmax" class="headerlink" title="/proc/sys/kernel/shmmax"></a>/proc/sys/kernel/shmmax</h2><p>该文件可用于查询和设置对可创建的最大（System V IPC）共享内存段大小的运行时限制。 内核现在支持高达1 GB的共享内存段。 此值默认为SHMMAX。</p>
<h2 id="proc-sys-kernel-shmmni"><a href="#proc-sys-kernel-shmmni" class="headerlink" title="/proc/sys/kernel/shmmni"></a>/proc/sys/kernel/shmmni</h2><p>该文件指定了系统范围内可以创建的System V共享内存段的最大数目。</p>
<h2 id="proc-sys-kernel-sysctl-writes-strict"><a href="#proc-sys-kernel-sysctl-writes-strict" class="headerlink" title="/proc/sys/kernel/sysctl_writes_strict"></a>/proc/sys/kernel/sysctl_writes_strict</h2><p>此文件中的值确定文件偏移量如何影响/ proc / sys下文件中更新条目的行为。 该文件具有三个可能的值：</p>
<p>-1：这提供了传统处理，没有printk警告。 每个write（2）必须完全包含要写入的值，并且在同一文件描述符上进行多次写入将覆盖整个值，而不管文件的位置如何。</p>
<p>0（默认）：这提供与-1相同的行为，但是对于文件偏移量不为0时执行写操作的进程会写出printk警告。</p>
<p>1：将字符串写入/ proc / sys文件时，请注意文件偏移量。 多次写入将追加到值缓冲区。 超出值缓冲区最大长度的任何内容都将被忽略。 写入 数字/ proc / sys条目必须始终位于文件偏移量0处，并且该值必须完全包含在提供给write（2）的缓冲区中。</p>
<h2 id="proc-sys-kernel-sysrq"><a href="#proc-sys-kernel-sysrq" class="headerlink" title="/proc/sys/kernel/sysrq"></a>/proc/sys/kernel/sysrq</h2><p>该文件控制允许由SysRq键调用的功能。 默认情况下，该文件包含1，表示允许所有可能的SysRq请求（在较早的内核版本中，默认情况下禁用SysRq，并且您需要在运行时专门启用它，但现在不再是这种情况）。 该文件中的可能值为：</p>
<p>​              0    Disable sysrq completely</p>
<p>​              1    Enable all functions of sysrq</p>
<p>​              &gt; 1  Bit mask of allowed sysrq functions, as follows:<br>​                     2  Enable control of console logging level<br>​                     4  Enable control of keyboard (SAK, unraw)<br>​                     8  Enable debugging dumps of processes etc.<br>​                    16  Enable sync command<br>​                    32  Enable remount read-only<br>​                    64  Enable signaling of processes (term, kill, oom-kill)<br>​                   128  Allow reboot/poweroff<br>​                   256  Allow nicing of all real-time tasks</p>
<p>​              This file is present only if the CONFIG_MAGIC_SYSRQ kernel configuration option is enabled.  For further details see the Linux kernel source file Documentation/admin-guide/sysrq.rst (or Documentation/sysrq.txt before Linux 4.10).</p>
<h2 id="proc-sys-kernel-version"><a href="#proc-sys-kernel-version" class="headerlink" title="/proc/sys/kernel/version"></a>/proc/sys/kernel/version</h2><p>该文件包含一个字符串，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#5 Wed Feb 25 21:49:24 MET 1998</span><br></pre></td></tr></table></figure>
<p>“＃5”表示这是从该源库构建的第五个内核，其后的日期表示构建内核的时间。</p>
<h2 id="proc-sys-kernel-threads-max"><a href="#proc-sys-kernel-threads-max" class="headerlink" title="/proc/sys/kernel/threads-max"></a>/proc/sys/kernel/threads-max</h2><p>该文件指定系统范围内可以在系统上创建的线程（任务）数量的限制。</p>
<p>从Linux 4.1开始，可以写入threads-max的值是有界的。 可写入的最小值为20。可写入的最大值由常数FUTEX_TID_MASK（0x3fffffff）给出。 如果将超出此范围的值写入threads-max，则会发生错误EINVAL。</p>
<p>根据可用的RAM页检查写入的值。 如果线程结构将占用过多的可用RAM页（超过1/8），则会相应地减少threads-max。</p>
<h2 id="proc-sys-kernel-yama-ptrace-scope"><a href="#proc-sys-kernel-yama-ptrace-scope" class="headerlink" title="/proc/sys/kernel/yama/ptrace_scope"></a>/proc/sys/kernel/yama/ptrace_scope</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace(2)</a>.</p>
<p>在安装了Yama Linux安全模块（LSM）（即，内核已配置CONFIG_SECURITY_YAMA）的系统上，/ proc / sys / kernel / yama / ptrace_scope文件（自Linux 3.4起可用）可用于限制跟踪功能 具有ptrace（）的进程（因此也具有使用诸如strace（1）和gdb（1）之类的工具的能力）。 此类限制的目的是防止攻击升级，从而使受感染的进程可以ptrace-attach附加到用户拥有的其他敏感进程（例如，GPG代理或SSH会话），以获得可能存在于内存中的附加凭据，因此 扩大攻击范围。</p>
<p>0（“classic ptrace permissions”）<br>       对执行PTRACE_MODE_ATTACH检查的操作没有其他限制（除了commoncap和其他LSM施加的限制之外）。 PTRACE_TRACEME的使用保持不变。</p>
<h2 id="proc-sys-net"><a href="#proc-sys-net" class="headerlink" title="/proc/sys/net"></a>/proc/sys/net</h2><p>该目录包含网络内容。 可以在<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/tcp.7.html">tcp（7）</a>和<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/ip.7.html">ip（7）</a>中找到此目录下某些文件的说明。</p>
<h2 id="proc-sys-net-core"><a href="#proc-sys-net-core" class="headerlink" title="/proc/sys/net/core/"></a>/proc/sys/net/core/</h2><p>目录包含各种设置，这些设置控制内核和网络层之间的交互。这些文件中最重要的是</p>
<ul>
<li><p><code>message_burst</code> — 设置写新警告消息所需的时间（以十分之一秒为单位）。此设置用于缓解拒绝服务（DoS）攻击。默认设置为 <code>50</code>.</p>
</li>
<li><p><code>message_cost</code> — 设置每条警告消息的成本。此文件的值越高（默认值<code>5</code>），则警告消息被忽略的可能性越大。此设置用于缓解DoS攻击.</p>
<p>DoS攻击的目的是用产生错误的请求轰炸目标系统，并用日志文件填充磁盘分区，或者需要系统的所有资源来处理错误日志。 <code>message_burst</code>和<code>message_cost</code>中的设置旨在根据系统可接受的风险与全面日志记录的需求进行修改。</p>
</li>
<li><p><code>netdev_max_backlog</code> — 设置当特定接口接收数据包的速度快于内核处理数据包时允许排队的最大数据包数量。该文件的默认值为<code>300</code>.</p>
</li>
<li><p><code>optmem_max</code> — 配置每个套接字允许的最大辅助缓冲区大小.</p>
</li>
<li><p><code>rmem_default</code> — 设置接收套接字缓冲区的默认大小（以字节为单位.</p>
</li>
<li><p><code>rmem_max</code> — 设置接收套接字缓冲区的最大大小（以字节为单位）。</p>
</li>
<li><p><code>wmem_default</code> — 设置发送套接字缓冲区的默认大小（以字节为单位）。</p>
</li>
<li><p><code>wmem_max</code> — 设置发送套接字缓冲区的最大大小（以字节为单位）</p>
</li>
</ul>
<h2 id="proc-sys-net-core-bpf-jit-enable"><a href="#proc-sys-net-core-bpf-jit-enable" class="headerlink" title="/proc/sys/net/core/bpf_jit_enable"></a>/proc/sys/net/core/bpf_jit_enable</h2><p>bps：在扩展的BPF映射或程序上执行命令 </p>
<p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf(2)</a>.</p>
<h2 id="proc-sys-net-core-somaxconn"><a href="#proc-sys-net-core-somaxconn" class="headerlink" title="/proc/sys/net/core/somaxconn"></a>/proc/sys/net/core/somaxconn</h2><p>这个文件为listen（2）的积压参数定义了一个最大值。 有关详细信息，请参见<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/listen.2.html">listen（2）</a>手册页。</p>
<h2 id="proc-sys-net-ipv4"><a href="#proc-sys-net-ipv4" class="headerlink" title="/proc/sys/net/ipv4"></a>/proc/sys/net/ipv4</h2><p>包含其他网络设置。这些设置中的许多设置相互结合使用，对于防止对系统的攻击或在使用系统充当路由器时很有用。</p>
<ul>
<li><code>icmp_destunreach_rate</code>, <code>icmp_echoreply_rate</code>, <code>icmp_paramprob_rate</code>, and <code>icmp_timeexeed_rate</code> — 在某些情况下，设置主机的最大ICMP发送数据包速率（以1/100秒为单位）。设置为0会消除任何延迟，这不是一个好主意.</li>
<li><code>icmp_echo_ignore_all</code> and <code>icmp_echo_ignore_broadcasts</code> — 允许内核忽略来自每个主机的ICMP ECHO数据包，或仅忽略分别来自广播和多播地址的ICMP ECHO数据包。值0允许内核响应，而值1则忽略数据包。</li>
<li><code>ip_default_ttl</code> — 设置默认的生存时间（TTL），该时间限制了数据包在到达目的地之前可能进行的跳数。增大此值可能会降低系统性能。 </li>
<li><code>ip_forward</code> — 允许系统上的 interface 相互转发数据包。默认情况下，此文件设置为0。将此文件设置为1将启用网络数据包转发。 </li>
<li><code>ip_local_port_range</code> — 指定需要本地端口时TCP或UDP使用的端口范围。第一个数字是要使用的最低端口，第二个数字指定了最高的端口。任何期望使用比默认的1024到4999更多端口的系统，应使用32768到61000的范围。</li>
<li><code>tcp_syn_retries</code> — 限制尝试建立连接时系统重新发送SYN数据包的次数.</li>
<li><code>tcp_retries1</code> — 设置尝试应答传入连接的允许重传次数。默认值为<code>3</code>.</li>
<li><code>tcp_retries2</code> — 设置允许的TCP数据包重传次数。默认值为<code>15</code></li>
</ul>
<p>/ proc / sys / net / ipv4 /目录中还存在许多其他目录，每个目录涵盖网络堆栈的不同方面。 / proc / sys / net / ipv4 / conf /目录允许以不同方式配置每个系统接口，包括未配置设备的默认设置（在/ proc / sys / net / ipv4 / conf / default /子目录中） ）和覆盖所有特殊配置的设置（在/ proc / sys / net / ipv4 / conf / all /子目录中）。</p>
<p>/ proc / sys / net / ipv4 / neigh /目录包含用于与直接连接到系统的主机（称为网络邻居）进行通信的设置，还为超过一跳的系统包含不同的设置。</p>
<p>通过IPV4进行路由也有其自己的目录/ proc / sys / net / ipv4 / route /。与conf /和neigh /不同，/ proc / sys / net / ipv4 / route /目录包含适用于使用系统上任何接口进行路由的规范。其中许多设置（例如max_size，max_delay和min_delay）都与控制路由缓存的大小有关。要清除路由缓存，请将任何值写入刷新文件。 </p>
<h2 id="proc-sys-user"><a href="#proc-sys-user" class="headerlink" title="/proc/sys/user"></a>/proc/sys/user</h2><p>See <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/namespaces.7.html">namespaces(7)</a>.</p>
<p>/ proc / sys / user目录（从Linux 4.9开始存在）中的文件公开了对可以创建的各种类型的名称空间数量的限制</p>
<h2 id="proc-sys-vm"><a href="#proc-sys-vm" class="headerlink" title="/proc/sys/vm"></a>/proc/sys/vm</h2><p>该目录包含用于内存管理调整，缓冲区（buffer）和缓存（cache）管理的文件。</p>
<h2 id="proc-sys-vm-admin-reserve-kbytes"><a href="#proc-sys-vm-admin-reserve-kbytes" class="headerlink" title="/proc/sys/vm/admin_reserve_kbytes"></a>/proc/sys/vm/admin_reserve_kbytes</h2><p>该文件定义系统上应为具有CAP_SYS_ADMIN功能的用户保留的可用内存量（以KiB为单位）。</p>
<p>此文件中的默认值是[3% of free pages, 8MiB]中的最小值，表示为KiB。 默认值旨在在默认的overcommit ‘guess’ 模式（即/ proc / sys / vm / overcommit_memory中为0）下为超级用户提供足够的登录和终止进程的内存（如有必要）。</p>
<p>以“overcommit never””模式运行的系统（即，/ proc / sys / vm / overcommit_memory中为2）应增加此文件中的值，以说明用于恢复的程序的完整虚拟内存大小（例如，login（1） ssh（1）和top（1））否则，超级用户可能无法登录以恢复系统。 例如，在x86-64上，合适的值为131072（保留128MiB）。</p>
<p>每当应用程序请求内存时，更改此文件中的值都会生效。</p>
<h2 id="proc-sys-vm-compact-memory"><a href="#proc-sys-vm-compact-memory" class="headerlink" title="/proc/sys/vm/compact_memory"></a>/proc/sys/vm/compact_memory</h2><p>将1写入此文件时，将压缩所有区域，以便在可能的情况下在连续的块中提供可用内存。 通过查看/ proc / buddyinfo可以看到此操作的效果。</p>
<p>仅当内核配置了CONFIG_COM-PACTION时才显示。</p>
<h2 id="proc-sys-vm-drop-caches"><a href="#proc-sys-vm-drop-caches" class="headerlink" title="/proc/sys/vm/drop_caches"></a>/proc/sys/vm/drop_caches</h2><p>写入此文件会导致内核从内存中删除干净的缓存，目录缓存和 索引节点/inode，从而导致该内存变为可用。 这对于内存管理测试和执行可重现的文件系统基准测试很有用。 由于写入此文件会导致失去缓存的好处，因此会降低整体系统性能。</p>
<p>要释放页面缓存，请使用：</p>
<pre><code>echo 1&gt; / proc / sys / vm / drop_caches</code></pre>
<p>要释放目录缓存和索引节点，请使用：</p>
<pre><code>echo 2&gt; / proc / sys / vm / drop_caches</code></pre>
<p>要释放页面缓存，目录缓存和索引节点，请使用：</p>
<pre><code>echo 3&gt; / proc / sys / vm / drop_caches</code></pre>
<p>由于写入此文件是非破坏性的操作，脏对象不可释放，因此用户应首先运行sync（1）。</p>
<h2 id="proc-sys-vm-legacy-va-layout"><a href="#proc-sys-vm-legacy-va-layout" class="headerlink" title="/proc/sys/vm/legacy_va_layout"></a>/proc/sys/vm/legacy_va_layout</h2><p>如果非零，则禁用新的32位内存映射布局； 内核将对所有进程使用旧版（2.4）布局。</p>
<h2 id="proc-sys-vm-memory-failure-early-kill"><a href="#proc-sys-vm-memory-failure-early-kill" class="headerlink" title="/proc/sys/vm/memory_failure_early_kill"></a>/proc/sys/vm/memory_failure_early_kill</h2><p>控制当硬件在后台检测到内核无法处理的未纠正的内存错误（通常是内存模块中的2位错误）时，如何终止进程。 在某些情况下（例如页面在磁盘上仍具有有效副本），内核将透明地处理故障，而不影响任何应用程序。 但是，如果没有其他最新数据副本，它将杀死进程以防止传播任何数据损坏。</p>
<p>该文件具有以下值之一：</p>
<p>1：在检测到损坏后，立即杀死所有映射了损坏且不可重新加载的页面的进程。 请注意，某些类型的页面（例如内核内部分配的数据或交换缓存）不支持此功能，但适用于大多数用户页面。</p>
<p>0：从所有进程中取消映射损坏的页面，并仅在尝试访问该页面时才杀死该进程。</p>
<h2 id="proc-sys-vm-memory-failure-recovery"><a href="#proc-sys-vm-memory-failure-recovery" class="headerlink" title="/proc/sys/vm/memory_failure_recovery"></a>/proc/sys/vm/memory_failure_recovery</h2><p>启用内存故障恢复（在平台支持时）。</p>
<pre><code>1：尝试恢复。

0：总是对内存故障感到panic</code></pre>
<p>仅当内核配置有CONFIG_MEMORY_FAILURE时显示。</p>
<h2 id="proc-sys-vm-oom-dump-tasks"><a href="#proc-sys-vm-oom-dump-tasks" class="headerlink" title="/proc/sys/vm/oom_dump_tasks"></a>/proc/sys/vm/oom_dump_tasks</h2><p>当内核执行OOM-killing 时，可以生成系统范围的任务转储（不包括内核线程）。 转储包含每个任务（线程，进程）的以下信息：thread ID, real user ID, thread group ID (process ID), virtual memory size, resident set size, the CPU that the task is scheduled on, oom_adj score （ 请参阅/ proc / [pid] / oom_adj的说明）和command name。 这有助于确定为什么调用OOM-killer，并确定导致它的异常任务。</p>
<p>如果其中包含零值，那么将禁止显示此信息。 在具有数千个任务的超大型系统上，为每个任务转储内存状态信息可能是不可行的。 当可能不需要这些信息时，不应强迫此类系统在OOM情况下导致性能下降。</p>
<p>如果将其设置为非零，则无论何时OOM杀手实际终止占用内存的任务，都会显示此信息。</p>
<p>默认值为0。</p>
<h2 id="proc-sys-vm-oom-kill-allocating-task"><a href="#proc-sys-vm-oom-kill-allocating-task" class="headerlink" title="/proc/sys/vm/oom_kill_allocating_task"></a>/proc/sys/vm/oom_kill_allocating_task</h2><p>这在内存不足的情况下启用或禁用杀死OOM-triggering。</p>
<p>如果将其设置为零，则OOM-killer将扫描整个任务列表，并根据 启发式/heuristics 方法选择要杀死的任务。 通常，这会选择异常的内存占用任务，该任务在被杀死时会释放大量内存。</p>
<p>如果将其设置为非零，则OOM杀手会简单地杀死触发内存不足情况的任务。 这避免了可能昂贵的任务列表扫描。</p>
<p>如果/ proc / sys / vm / panic_on_oom不为零，则它将优先于/ proc / sys / vm / oom_kill_allocating_task中使用的任何值。</p>
<p>默认值为0。</p>
<h2 id="proc-sys-vm-overcommit-kbytes"><a href="#proc-sys-vm-overcommit-kbytes" class="headerlink" title="/proc/sys/vm/overcommit_kbytes"></a>/proc/sys/vm/overcommit_kbytes</h2><p>/ proc / sys / vm / overcommit_kbytes（从Linux 3.14开始），当/ proc / sys / vm / overcommit_memory值为2时，此可写文件提供了/ proc / sys / vm / overcommit_ratio的替代方法，用于控制CommitLimit。 内存过量使用的单位应指定为绝对值（以kB为单位），而不是百分比，如overcommit_ratio那样。 这样可以在内存容量极大的系统上对CommitLimit进行更细粒度的控制。</p>
<p>overcommit_kbytes或overcommit_ratio中只有一个可以起作用：如果overcommit_kbytes具有非零值，则将其用于计算CommitLimit，否则将使用overcommit_ratio。 向这些文件中的任何一个写入值都会导致另一个文件中的值设置为零。</p>
<h2 id="proc-sys-vm-overcommit-memory"><a href="#proc-sys-vm-overcommit-memory" class="headerlink" title="/proc/sys/vm/overcommit_memory"></a>/proc/sys/vm/overcommit_memory</h2><p>该文件包含内核虚拟内存记帐模式。值是：</p>
<p>0：heuristic overcommit（这是默认设置）<br>1：always overcommit，从不检查<br>2：始终检查，永不过度使用</p>
<p>在模式0下，不检查使用MAP_NORESERVE调用mmap（2），并且默认检查非常弱，导致存在使进程“ OOM终止”的风险。</p>
<p>在模式1中，内核假装总是有足够的内存，直到内存实际用完为止。这种模式的一个用例是采用大型稀疏阵列的科学计算应用程序。在2.6.0之前的Linux内核版本中，任何非零值都表示模式1。</p>
<p>在模式2（自Linux 2.6起可用）中，可以分配的总虚拟地址空间（/ proc / meminfo中的ComitLimit）计算为</p>
<p>CommitLimit =（total_RAM-total_huge_TLB）*过度分配比率/ 100 + total_swap</p>
<p>哪里：</p>
<ul>
<li><p>total_RAM是系统上的RAM总量；</p>
</li>
<li><p>total_huge_TLB是为大页面预留的内存量；</p>
</li>
<li><p>overcommit_ratio是/ proc / sys / vm / overcommit_ratio中的值；</p>
</li>
<li><p>total_swap是交换空间的数量。</p>
</li>
</ul>
<p>例如，在具有16 GB物理RAM，16 GB交换空间，没有专用于大页面的空间以及overcommit_ratio为50的系统上，此公式得出的CommitLimit为24 GB。</p>
<p>从Linux 3.14开始，如果/ proc / sys / vm / overcommit_kbytes中的值非零，则将CommitLimit计算为：</p>
<p>CommitLimit = overcommit_kbytes + total_swap</p>
<p>另请参见/ proc / sys / vm / admin_reserve_kbytes和/ proc / sys / vm / user_reserve_kbytes的说明。</p>
<h2 id="proc-sys-vm-overcommit-ratio"><a href="#proc-sys-vm-overcommit-ratio" class="headerlink" title="/proc/sys/vm/overcommit_ratio"></a>/proc/sys/vm/overcommit_ratio</h2><p>该可写文件定义了内存过量使用的百分比。 文件中的默认值为50。请参见/ proc / sys / vm / overcommit_memory的说明。</p>
<h2 id="proc-sys-vm-panic-on-oom"><a href="#proc-sys-vm-panic-on-oom" class="headerlink" title="/proc/sys/vm/panic_on_oom"></a>/proc/sys/vm/panic_on_oom</h2><p>这在内存不足的情况下启用或禁用内核崩溃。</p>
<p>如果此文件的值设置为0，则内核的OOM-killer将杀死一些恶意进程。 通常，OOM杀手可以杀死流氓进程，并且系统可以生存。</p>
<p>如果将此文件设置为值1，则在发生内存不足时，内核通常会出现紧急情况。 但是，如果某个进程使用内存策略（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mbind.2.html">mbind（2）</a>MPOL_BIND）或cpusets（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/cpuset.7.html">cpuset（7）</a>）限制了对某些节点的分配，并且这些节点达到内存耗尽状态，则OOM杀手可能会杀死一个进程。 在这种情况下不会发生紧急情况：因为其他节点的内存可能已空闲，这意味着整个系统可能尚未达到内存不足的情况。</p>
<p>如果将此文件设置为值2，则在内存不足的情况下，内核始终会出现紧急情况。</p>
<p>默认值为0。1和2用于群集的故障转移。 根据您的故障转移策略选择。</p>
<h2 id="proc-sys-vm-swappiness"><a href="#proc-sys-vm-swappiness" class="headerlink" title="/proc/sys/vm/swappiness"></a>/proc/sys/vm/swappiness</h2><p>该文件中的值控制内核将多积极地交换内存页面。 较高的值会增加交换，较低的值会降低交换。 默认值为60。</p>
<h2 id="proc-sys-vm-user-reserve-kbytes"><a href="#proc-sys-vm-user-reserve-kbytes" class="headerlink" title="/proc/sys/vm/user_reserve_kbytes"></a>/proc/sys/vm/user_reserve_kbytes</h2><p>指定要为用户进程保留的内存量（以KiB为单位）。 这旨在防止用户启动单个内存占用进程，以使他们无法恢复（杀死该进程）。</p>
<p>仅当将/ proc / sys / vm / overcommit_memory设置为2（“overcommit never”模式）时，此文件中的值才有效。</p>
<p>在这种情况下，系统保留的内存量至少为[当前进程大小的3％，user_reserve_kbytes]。</p>
<p>此文件中的默认值是[3% of free pages，128MiB]中的最小值，表示为KiB。</p>
<p>如果此文件中的值设置为零，则将允许用户通过单个进程分配所有可用内存（减去/ proc / sys / vm / admin_reserve_kbytes保留的数量）。 任何随后的执行命令的尝试都将导致“ fork: Cannot allocate memory”。</p>
<p>每当应用程序请求内存时，更改此文件中的值都会生效。</p>
<h2 id="proc-sysrq-trigger"><a href="#proc-sysrq-trigger" class="headerlink" title="/proc/sysrq-trigger"></a>/proc/sysrq-trigger</h2><p>向此文件写入字符会触发与键入ALT-SysRq- &lt;字符&gt;相同的SysRq函数（请参阅/ proc / sys / kernel / sysrq的说明）。 该文件通常只能由root写入。 有关更多详细信息，请参见Linux内核源文件Documentation / admin-guide / sysrq.rst（或Linux 4.10之前的Documentation / sysrq.txt）。</p>
<h2 id="proc-sysvipc"><a href="#proc-sysvipc" class="headerlink" title="/proc/sysvipc"></a>/proc/sysvipc</h2><p>包含伪文件msg，sem和shm的子目录。 这些文件列出了系统上当前存在的System V进程间通信（IPC）对象（分别：消息队列，信号量和共享内存），提供了与可通过<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/ipcs.1.html">ipcs（1）</a>获得的信息类似的信息。 这些文件具有标头，并且已进行了格式化（每行一个IPC对象），以便于理解。 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sysvipc.7.html">sysvipc（7）</a>为这些文件显示的信息提供了进一步的背景信息。</p>
<h2 id="proc-timer-list"><a href="#proc-timer-list" class="headerlink" title="/proc/timer_list"></a>/proc/timer_list</h2><p>此只读文件以人类可读的形式公开了所有当前待处理（高分辨率）计时器，所有时钟事件源及其参数的列表。</p>
<h2 id="proc-timer-stats"><a href="#proc-timer-stats" class="headerlink" title="/proc/timer_stats"></a>/proc/timer_stats</h2><p>这是一种调试工具，用于使内核和用户空间开发人员可以在Linux系统中使用计时器。内核和用户空间开发人员可以使用它来验证其代码没有过度使用计时器。目的是避免不必要的唤醒，从而优化功耗。</p>
<h2 id="proc-tty"><a href="#proc-tty" class="headerlink" title="/proc/tty"></a>/proc/tty</h2><p>包含tty drivers  和  line disciplines 的伪文件和子目录。</p>
<h2 id="proc-uptime"><a href="#proc-uptime" class="headerlink" title="/proc/uptime"></a>/proc/uptime</h2><p>该文件包含两个数字（以秒为单位的值）：系统的正常运行时间（包括挂起所花费的时间）和空闲进程所花费的时间。</p>
<h2 id="proc-version"><a href="#proc-version" class="headerlink" title="/proc/version"></a>/proc/version</h2><p>该字符串标识当前正在运行的内核版本。 它包含/ proc / sys / kernel / ostype，/ proc / sys / kernel / osrelease和/ proc / sys / kernel / version的内容。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994</span><br></pre></td></tr></table></figure>
<h2 id="proc-vmstat"><a href="#proc-vmstat" class="headerlink" title="/proc/vmstat"></a>/proc/vmstat</h2><p>该文件显示各种虚拟内存统计信息。 该文件的每一行都包含一个 name-value 对，以空格分隔。 仅当内核配置了适当的选项时，才会显示某些行。 （在某些情况下，特定文件所需的选项在内核版本之间有所变化，因此未在此处列出。有关详细信息，请查阅内核源代码。）可能存在以下字段，见官网</p>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2020-09-01</p></div> 
    <div class="post-meta__cats"></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/heavyfish.github.io/2020/09/02/Linux/history%E5%91%BD%E4%BB%A4%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E6%88%B3/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            no title
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/heavyfish.github.io/2020/08/04/k8s/k8s%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            no title
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2021 <a href="/heavyfish.github.io/">速查笔记</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

  



 


    
 

 

 

 

 




    </body>
</html>
