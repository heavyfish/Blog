<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
    
    


    <!-- meta -->


<title>no title | 速查笔记</title>





    <!-- OpenGraph -->
 
    <meta name="description" content="1、概览1.1、nginx是什么Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。 Nginx 做为 HTTP 服务器，有以下几项基本特性：  处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 无缓存的反向代理加速，简单的负载均衡和容错． F">
<meta property="og:type" content="article">
<meta property="og:title" content="速查笔记">
<meta property="og:url" content="https://heavyfish.github.io/2020/12/14/Linux/Nginx/index.html">
<meta property="og:site_name" content="速查笔记">
<meta property="og:description" content="1、概览1.1、nginx是什么Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。 Nginx 做为 HTTP 服务器，有以下几项基本特性：  处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 无缓存的反向代理加速，简单的负载均衡和容错． F">
<meta property="og:locale">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/wk/nginx/chapter-4-1.png">
<meta property="og:image" content="https://www.aosabook.org/images/nginx/architecture.png">
<meta property="article:published_time" content="2020-12-14T07:31:26.586Z">
<meta property="article:modified_time" content="2020-12-15T09:46:14.164Z">
<meta property="article:author" content="Shenxr">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://atts.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png">


    
<link rel="stylesheet" href="/heavyfish.github.io/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/heavyfish.github.io/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.3.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/heavyfish.github.io/" class="button">
            <span class="logo__text">Demo</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/heavyfish.github.io/" class="navbar-menu button">首页</a>
                
                    <a href="/heavyfish.github.io/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/heavyfish.github.io/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/heavyfish.github.io/friends/" class="navbar-menu button">友链</a>
                
                    <a href="/heavyfish.github.io/page/" class="navbar-menu button">Page</a>
                
            </div>
        
        
        

        
        

        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/heavyfish.github.io/" class="dropdown-menu button">首页</a>
                
                    <a href="/heavyfish.github.io/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/heavyfish.github.io/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/heavyfish.github.io/friends/" class="dropdown-menu button">友链</a>
                
                    <a href="/heavyfish.github.io/page/" class="dropdown-menu button">Page</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        no title
    </h1>
    <div class="post-title__meta">
        <a href="/heavyfish.github.io/archives/2020/12/" class="post-meta__date button">2020-12-14</a>
        
 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h1 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h1><h2 id="1-1、nginx是什么"><a href="#1-1、nginx是什么" class="headerlink" title="1.1、nginx是什么"></a>1.1、nginx是什么</h2><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。</p>
<p>Nginx 做为 HTTP 服务器，有以下几项基本特性：</p>
<ul>
<li>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</li>
<li>无缓存的反向代理加速，简单的负载均衡和容错．</li>
<li>FastCGI，简单的负载均衡和容错．</li>
<li>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。</li>
<li>支持 SSL 和 TLSSNI．</li>
</ul>
<p>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。</p>
<p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行升级。</p>
<p>Nginx 采用 master-slave 模型,能够充分利用 SMP 的优势，且能够减少工作进程在磁盘 I/O 的阻塞延迟。当采用 select()/poll() 调用时，还可以限制每个进程的连接数。</p>
<p>Nginx 代码质量非常高，代码很规范，手法成熟，模块扩展也很容易。特别值得一提的是强大的 Upstream 与 Filter 链。Upstream 为诸如 reverse proxy,与其他服务器通信模块的编写奠定了很好的基础。而 Filter 链最酷的部分就是各个 filter 不必等待前一个 filter 执行完毕。它可以把前一个 filter 的输出做为当前 filter 的输入，这有点像 Unix 的管线。这意味着，一个模块可以开始压缩从后端服务器发送过来的请求，且可以在模块接收完后端服务器的整个请求之前把压缩流转向客户端。</p>
<p>Nginx 采用了一些 os 提供的最新特性如对 sendfile (Linux2.2+)，accept-filter (FreeBSD4.1+)，TCP_DEFER_ACCEPT (Linux 2.4+)的支持，从而大大提高了性能。</p>
<h2 id="1-2、nginx的架构"><a href="#1-2、nginx的架构" class="headerlink" title="1.2、nginx的架构"></a>1.2、nginx的架构</h2><p>Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。</p>
<p>Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与 Nginx 的进程模型以及事件处理模型是分不开的。Nginx 的进程模型，可以由下图来表示：</p>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/nginx/chapter-2-1.png" alt="img"></p>
<p>worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。</p>
<p>Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>
<p>Nginx的异步非阻塞的事件处理机制，具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。</p>
<h2 id="1-3、Nginx的模块化体系结构"><a href="#1-3、Nginx的模块化体系结构" class="headerlink" title="1.3、Nginx的模块化体系结构"></a>1.3、Nginx的模块化体系结构</h2><h3 id="Nginx-的模块化体系结构"><a href="#Nginx-的模块化体系结构" class="headerlink" title="Nginx 的模块化体系结构"></a>Nginx 的模块化体系结构</h3><p>Nginx 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。为了便于描述，下文中我们将使用 Nginx core 来称呼 Nginx 的核心功能部分。</p>
<p>Nginx 提供了 Web 服务器的基础功能，同时提供了 Web 服务反向代理，Email 服务反向代理功能。Nginx core实现了底层的通讯协议，为其他模块和 Nginx 进程构建了基本的运行时环境，并且构建了其他各模块的协作基础。除此之外，或者说大部分与协议相关的，或者应用相关的功能都是在这些模块中所实现的。</p>
<h3 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h3><p>Nginx 将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现 SSI 的模块，实现与上游服务器进行通讯的模块，实现与 FastCGI 服务进行通讯的模块。</p>
<p>有两个模块比较特殊，他们居于 Nginx core 和各功能模块的中间。这两个模块就是 http 模块和 mail 模块。这 2 个模块在 Nginx core 之上实现了另外一层抽象，处理与 HTTP 协议和 Email 相关协议（SMTP/POP3/IMAP）有关的事件，并且确保这些事件能被以正确的顺序调用其他的一些功能模块。</p>
<p>目前 HTTP 协议是被实现在 http 模块中的，但是有可能将来被剥离到一个单独的模块中，以扩展 Nginx 支持 SPDY 协议。</p>
<h3 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h3><p>Nginx 的模块根据其功能基本上可以分为以下几种类型：</p>
<ul>
<li>event module: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括 ngx_events_module， ngx_event_core_module和ngx_epoll_module 等。Nginx 具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。</li>
<li>phase handler: 此类型的模块也被直接称为 handler 模块。主要负责处理客户端请求并产生待响应内容，比如 ngx_http_static_module 模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>
<li>output filter: 也称为 filter 模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有 html 页面增加预定义的 footbar 一类的工作，或者对输出的图片的 URL 进行替换之类的工作。</li>
<li>upstream: upstream 模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream 模块是一种特殊的 handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>
<li>load-balancer: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</li>
</ul>
<h2 id="1-4、Nginx的请求处理"><a href="#1-4、Nginx的请求处理" class="headerlink" title="1.4、Nginx的请求处理"></a>1.4、Nginx的请求处理</h2><h3 id="Nginx-的请求处理"><a href="#Nginx-的请求处理" class="headerlink" title="Nginx 的请求处理"></a>Nginx 的请求处理</h3><p>Nginx 使用一个多进程模型来对外提供服务，其中一个 master 进程，多个 worker 进程。master 进程负责管理 Nginx 本身和其他 worker 进程。</p>
<p>所有实际上的业务处理逻辑都在 worker 进程。worker 进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个 Nginx 服务被停止。</p>
<p>worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</p>
<ul>
<li>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。</li>
<li>接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。</li>
<li>处理 request 的 header 和 body。</li>
<li>产生响应，并发送回客户端。</li>
<li>完成 request 的处理。</li>
<li>重新初始化定时器及其他事件。</li>
</ul>
<h3 id="请求的处理流程"><a href="#请求的处理流程" class="headerlink" title="请求的处理流程"></a>请求的处理流程</h3><p>为了让大家更好的了解 Nginx 中请求处理过程，我们以 HTTP Request 为例，来做一下详细地说明。</p>
<p>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段。</p>
<ul>
<li>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。</li>
<li>处理请求头。</li>
<li>处理请求体。</li>
<li>如果有的话，调用与此请求（URL 或者 Location）关联的 handler。</li>
<li>依次调用各 phase handler 进行处理。</li>
</ul>
<p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。</p>
<p>在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p>
<p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler 是与定义在配置文件中的某个 location 相关联的。</p>
<p>一个 phase handler 通常执行以下几项任务：</p>
<ul>
<li>获取 location 配置。</li>
<li>产生适当的响应。</li>
<li>发送 response header。</li>
<li>发送 response body。</li>
</ul>
<p>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）：</p>
<ul>
<li>NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</li>
<li>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</li>
<li>NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段:</li>
<li>NGX_HTTP_REWRITE_PHASE: Location请求地址重写阶段</li>
<li>NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</li>
<li>NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</li>
<li>NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</li>
<li>NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</li>
<li>NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</li>
<li>NGX_HTTP_CONTENT_PHASE: 内容产生阶段</li>
<li>NGX_HTTP_LOG_PHASE: 日志模块处理阶段</li>
</ul>
<p>在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4等。</p>
<p>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试:</p>
<ul>
<li>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。</li>
<li>如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。</li>
<li>如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。</li>
<li>如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的<code>.gz</code>文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。</li>
<li>请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</li>
</ul>
<p>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 fiter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p>
<p>这里列举几个常见的 filter 模块，例如：</p>
<ul>
<li>server-side includes。</li>
<li>XSLT filtering。</li>
<li>图像缩放之类的。</li>
<li>gzip 压缩。</li>
</ul>
<p>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</p>
<ul>
<li>write: 写输出到客户端，实际上是写到连接对应的 socket 上。</li>
<li>postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</li>
<li>copy: 将一些需要复制的 buf(文件或者内存)重新复制一份然后交给剩余的 body filter 处理。</li>
</ul>
<h2 id="1-5、Nginx的连接数"><a href="#1-5、Nginx的连接数" class="headerlink" title="1.5、Nginx的连接数"></a>1.5、Nginx的连接数</h2><p>在 Nginx 中，每个进程会有一个连接数的最大上限，这个上限与系统对 fd 的限制不一样。在操作系统中，通过 <code>ulimit -n</code>，我们可以得到一个进程所能够打开的 fd 的最大数，即 nofile，因为每个 socket 连接会占用掉一个 fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当 fd 用完后，再创建 socket 时，就会失败。Nginx 通过设置 worker_connectons 来设置每个进程支持的最大连接数。如果该值大于 nofile，那么实际的最大连接数是 nofile，Nginx 会有警告。Nginx 在实现时，是通过一个连接池来管理的，每个 worker 进程都有一个独立的连接池，连接池的大小是 worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个 worker_connections 大小的一个 ngx_connection_t 结构的数组。并且，Nginx 会通过一个链表 free_connections 来保存所有的空闲 ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>
<p> worker_connections 这个参数的意思，表示每个 worker 进程所能建立连接的最大值，所以，一个 Nginx 能建立的最大连接数，应该是<code>worker_connections * worker_processes</code>。当然，这里说的是最大连接数，对于 HTTP 请求本地资源来说，能够支持的最大并发数量是<code>worker_connections * worker_processes</code>，而如果是 HTTP 作为反向代理来说，最大并发数量应该是<code>worker_connections * worker_processes/2</code>。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。现在 浏览器在发起连接时，会发起并行连接，因此最大并发数量应该是<code>worker_connections * worker_processes/4</code>。</p>
<h3 id="Nginx如何均衡worker的连接数"><a href="#Nginx如何均衡worker的连接数" class="headerlink" title="Nginx如何均衡worker的连接数"></a>Nginx如何均衡worker的连接数</h3><p>Nginx 的处理得先打开 accept_mutex 选项，此时，只有获得了 accept_mutex 的进程才会去添加accept事件，也就是说，Nginx会控制进程是否添加 accept 事件。Nginx 使用一个叫 ngx_accept_disabled 的变量来控制是否去竞争 accept_mutex 锁。在第一段代码中，计算 ngx_accept_disabled 的值，这个值是 Nginx 单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个 ngx_accept_disabled 有一个规律，当剩余连接数小于总连接数的八分之一时，其值才大于 0，而且剩余的连接数越小，这个值越大。再看第二段代码，当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁，并且将 ngx_accept_disabled 减 1，于是，每次执行到此处时，都会去减 1，直到小于 0。不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable 越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去 accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，Nginx 就控制了多进程间连接的平衡了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ngx_accept_disabled = ngx_cycle-&gt;connection_n / <span class="number">8</span></span><br><span class="line">    - ngx_cycle-&gt;free_connection_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">        &#123;</span><br><span class="line">            timer = ngx_accept_mutex_delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="connection-的内存消耗"><a href="#connection-的内存消耗" class="headerlink" title="connection 的内存消耗"></a>connection 的内存消耗</h3><p>每个连接数分别对应一个read_event、一个write_event事件，一个连接数大概占用232字节，2个事件总占用96字节，那么一个连接总共占用328字节，通过数学公式可以算出100000个连接数大概会占用 31M = 100000 * 328 / 1024 / 1024，当然这只是nginx启动时，connections连接数所占用的nginx。</p>
<h2 id="1-6、Nginx的模块概览"><a href="#1-6、Nginx的模块概览" class="headerlink" title="1.6、Nginx的模块概览"></a>1.6、Nginx的模块概览</h2><h3 id="core模块"><a href="#core模块" class="headerlink" title="core模块"></a>core模块</h3><p>core 模块 即是 Nginx 的启动模块</p>
<p>启动模块从启动 Nginx 进程开始，做了一系列的初始化工作，源代码位于<code>src/core/nginx.c</code>，从 main 函数开始:</p>
<ul>
<li>时间、正则、错误日志、ssl 等初始化</li>
<li>读入命令行参数</li>
<li>OS 相关初始化</li>
<li>读入并解析配置</li>
<li>核心模块初始化</li>
<li>创建各种暂时文件和目录</li>
<li>创建共享内存</li>
<li>打开 listen 的端口</li>
<li>所有模块初始化</li>
<li>启动 worker 进程</li>
</ul>
<h3 id="event-模块"><a href="#event-模块" class="headerlink" title="event 模块"></a>event 模块</h3><p>Nginx 是以 event（事件）处理模型为基础的模块。它为了支持跨平台，抽象出了 event 模块。它支持的 event 处理类型有：AIO（异步IO），/dev/poll（Solaris 和 Unix 特有），epoll（Linux 特有），eventport（Solaris 10 特有），kqueue（BSD 特有），poll，rtsig（实时信号），select 等。</p>
<p>event 模块的主要功能就是，监听 accept 后建立的连接，对读写事件进行添加删除。事件处理模型和 Nginx 的非阻塞 IO 模型结合在一起使用。当 IO 可读可写的时候，相应的读写事件就会被唤醒，此时就会去处理事件的回调函数。</p>
<p>特别对于 Linux，Nginx 大部分 event 采用 epoll EPOLLET（边沿触发）的方法来触发事件，只有 listen 端口的读事件是 EPOLLLT（水平触发）。对于边沿触发，如果出现了可读事件，必须及时处理，否则可能会出现读事件不再触发，连接饿死的情况</p>
<h3 id="handle-模块"><a href="#handle-模块" class="headerlink" title="handle 模块"></a>handle 模块</h3><p>Handler 模块就是接受来自客户端的请求并产生输出的模块。有些地方说 upstream 模块实际上也是一种 handler 模块，只不过它产生的内容来自于从后端服务器获取的，而非在本机产生的。</p>
<p>例如，配置文件中使用 location 指令可以配置 content handler 模块，当 Nginx 系统启动的时候，每个 handler 模块都有一次机会把自己关联到对应的 location上。如果有多个 handler 模块都关联了同一个 location，那么实际上只有一个 handler 模块真正会起作用。当然大多数情况下，模块开发人员都会避免出现这种情况。</p>
<p>handler 模块处理的结果通常有三种情况: 处理成功，处理失败（处理的时候发生了错误）或者是拒绝去处理。在拒绝处理的情况下，这个 location 的处理就会由默认的 handler 模块来进行处理。例如，当请求一个静态文件的时候，如果关联到这个 location 上的一个 handler 模块拒绝处理，就会由默认的 ngx_http_static_module 模块进行处理，该模块是一个典型的 handler 模块。</p>
<p>handler 模块 最终会返回 reponse 的 header 和 body</p>
<h3 id="filter-模块"><a href="#filter-模块" class="headerlink" title="filter 模块"></a>filter 模块</h3><p>过滤（filter）模块是过滤 response 的 header 和 body 的模块，可以对response 的 header 和 body进行处理。它的处理时间在获取 response body之后，向用户发送 response 之前。它的处理过程分为两个阶段，过滤 HTTP 回复的头部和主体，在这两个阶段可以分别对头部和主体进行修改。</p>
<p>响应头和响应体过滤函数的执行顺序如下所示：</p>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/nginx/chapter-4-1.png" alt="img"></p>
<p>这图只表示了 head_filter 和 body_filter 之间的执行顺序，在 header_filter 和 body_filter 处理函数之间，在 body_filter 处理函数之间，可能还有其他执行代码。</p>
<h3 id="upstream-模块"><a href="#upstream-模块" class="headerlink" title="upstream 模块"></a>upstream 模块</h3><p>upstream 模块，使 Nginx 跨越了单机的限制，完成网络数据的接收、处理和转发。</p>
<p>从本质上说，upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为 upstream（上游）。请求并取得响应内容的整个过程已经被封装到 Nginx 内部，所以 upstream 模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>
<h3 id="load-balancer-模块"><a href="#load-balancer-模块" class="headerlink" title="load-balancer 模块"></a>load-balancer 模块</h3><p>负载均衡模块用于从<code>upstream</code>指令定义的后端主机列表中选取一台主机。Nginx 先使用负载均衡模块找到一台主机，再使用 upstream 模块实现与这台主机的交互。</p>
<h2 id="1-7、Nginx的常用操作"><a href="#1-7、Nginx的常用操作" class="headerlink" title="1.7、Nginx的常用操作"></a>1.7、Nginx的常用操作</h2><h3 id="管理Nginx"><a href="#管理Nginx" class="headerlink" title="管理Nginx"></a>管理Nginx</h3><p>要启动nginx，请运行可执行文件。一旦nginx启动，就可以通过使用-s参数调用可执行文件来控制它。使用以下语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s signal</span><br></pre></td></tr></table></figure>
<p>signal 包括：</p>
<ul>
<li><code>stop</code> — fast shutdown</li>
<li><code>quit</code> — graceful shutdown</li>
<li><code>reload</code> — reloading the configuration file</li>
<li><code>reopen</code> — reopening the log files</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>

<p>此命令应该在启动nginx的同一用户下执行。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>一旦主进程接收到reload 信号，它将检查新配置文件的语法有效性，并尝试应用其中提供的配置。如果成功，主进程将启动新的工作进程并向旧的工作进程发送消息，请求它们关闭。否则，主进程回滚更改并继续使用旧配置。旧的工作进程，接收到关闭命令，停止接受新连接，并继续为当前请求提供服务，直到所有此类请求都得到处理。之后，旧的工作进程退出。</p>
</blockquote>
<p>在Unix工具（如kill实用程序）的帮助下，也可以向nginx进程发送信号。在这种情况下，信号被直接发送到具有给定进程ID的进程。可用的信号如下</p>
<p>用于Master进程的信号</p>
<table>
<thead>
<tr>
<th>TERM, INT</th>
<th>fast shutdown</th>
</tr>
</thead>
<tbody><tr>
<td>QUIT</td>
<td>graceful shutdown</td>
</tr>
<tr>
<td>HUP</td>
<td>更改配置，更新时区（仅适用于FreeBSD和Linux），用新配置启动新的工作进程，优雅地关闭旧的工作进程</td>
</tr>
<tr>
<td>USR1</td>
<td>re-opening log files</td>
</tr>
<tr>
<td>USR2</td>
<td>upgrading an executable file</td>
</tr>
<tr>
<td>WINCH</td>
<td>graceful shutdown of worker processes</td>
</tr>
</tbody></table>
<p>用于单独Worker进程的信号：</p>
<table>
<thead>
<tr>
<th>TERM, INT</th>
<th>fast shutdown</th>
</tr>
</thead>
<tbody><tr>
<td>QUIT</td>
<td>graceful shutdown</td>
</tr>
<tr>
<td>USR1</td>
<td>re-opening log files</td>
</tr>
<tr>
<td>WINCH</td>
<td>调试异常终止（需要启用调试点） (requires <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html#debug_points">debug_points</a> to be enabled)</td>
</tr>
</tbody></table>
<h3 id="动态更新可执行文件"><a href="#动态更新可执行文件" class="headerlink" title="动态更新可执行文件"></a>动态更新可执行文件</h3><ol>
<li>为了升级服务器可执行文件，应该先用新的可执行文件代替旧文件。为此，在USR2这个信号之后发送给主进程之后，主进程首先用进程ID将其文件重命名为后缀为.oldbin的新文件如/usr/local/nginx/logs/nginx.pid.oldbin，然后启动一个新的可执行文件，该文件又启动新的工作进程</li>
<li>之后，所有工作进程（旧进程和新进程）继续接受请求。如果 WINCH 信号被发送到第一个主进程，它将向其工作进程发送消息，请求它们优雅地关闭，它们将开始退出。一段时间后，只有新的工作进程将处理请求</li>
<li>需要注意的是，旧的主进程不会关闭它的侦听套接字，如果需要，可以管理它重新启动其工作进程。如果由于某种原因，新的可执行文件无法正常工作，可以执行以下操作之一：<ol>
<li>向旧的主进程发送HUP信号。旧的主进程将在不重新读取配置的情况下启动新的工作进程。然后，通过向新的主进程发送 QUIT 信号，可以优雅地关闭所有新进程。</li>
<li>向新的主进程发送 TERM 信号。然后，它将向其工作进程发送一条消息，请求它们立即退出，它们几乎都将立即退出。（如果新进程由于某种原因没有退出，则应该向它们发送 KILL 信号以强制它们退出。）当新的主进程退出时，旧的主进程将自动启动新的工作进程。</li>
<li>如果新主进程退出，则旧主进程将丢弃具有进程ID的文件名中的.oldbin后缀。</li>
</ol>
</li>
<li>如果升级成功，则应向旧主进程发送 QUIT 信号，只保留新进程</li>
</ol>
<h1 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h1><h2 id="2-1、yum默认configure"><a href="#2-1、yum默认configure" class="headerlink" title="2.1、yum默认configure"></a>2.1、yum默认configure</h2><p>完整编译参数见：<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/configure.html">Building nginx from Sources</a> 或 <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#">Installing NGINX Open Source</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义保存服务器文件的目录。该目录还将用于configure设置的所有相对路径（libiary源的路径除外）和nginx.conf配置文件。默认设置为/usr/<span class="built_in">local</span>/nginx目录</span></span><br><span class="line">--prefix=/usr/share/nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置nginx可执行文件的名称。此名称仅在安装过程中使用。默认情况下，文件名为prefix/sbin/nginx。</span></span><br><span class="line">--sbin-path=/usr/sbin/nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义将安装nginx动态模块的目录。默认情况下，使用prefix/modules。</span></span><br><span class="line">--modules-path=/usr/lib64/nginx/modules </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置nginx.conf配置文件的名称。如果需要的话，nginx总是可以用不同的配置文件启动，方法是在命令行参数-c文件中指定它。默认情况下，文件名为prefix/conf/nginx.conf</span></span><br><span class="line">--conf-path=/etc/nginx/nginx.conf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置主要错误，警告和诊断文件的名称。安装后，始终可以使用error_log指令在nginx.conf配置文件中更改文件名。默认情况下，该文件名为 prefix/logs/error.log</span></span><br><span class="line">--error-log-path=/var/log/nginx/error.log </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置HTTP服务器的主请求日志文件的名称。安装后，可以始终使用access_log指令在nginx.conf配置文件中更改文件名。默认情况下，该文件名为prefix/logs/access.log</span></span><br><span class="line">--http-log-path=/var/log/nginx/access.log </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义用于存储包含客户端 request bodies 的临时文件的目录。安装后，始终可以使用client_body_temp_path指令在nginx.conf配置文件中更改目录。默认情况下，该目录名为prefix/client_body_temp。</span></span><br><span class="line">--http-client-body-temp-path=/var/lib/nginx/tmp/client_body </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义用于存储包含从代理服务器接收到的数据的临时文件的目录。安装后，可以始终使用proxy_temp_path指令在nginx.conf配置文件中更改目录。默认情况下，该目录名为 prefix / proxy_temp。</span></span><br><span class="line">--http-proxy-temp-path=/var/lib/nginx/tmp/proxy </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个目录，用于存储包含从FastCGI服务器接收到的数据的临时文件。安装后，始终可以使用fastcgi_temp_path指令在nginx.conf配置文件中更改目录。默认情况下，该目录名为prefix / fastcgi_temp。</span></span><br><span class="line">--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个目录，用于存储包含从uwsgi服务器接收到的数据的临时文件。安装后，始终可以使用uwsgi_temp_path指令在nginx.conf配置文件中更改目录。默认情况下，该目录名为prefix / uwsgi_temp。</span></span><br><span class="line">--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个目录，用于存储包含从SCGI服务器接收到的数据的临时文件。安装后，可以始终使用scgi_temp_path指令在nginx.conf配置文件中更改目录。默认情况下，该目录名为prefix / scgi_temp。</span></span><br><span class="line">--http-scgi-temp-path=/var/lib/nginx/tmp/scgi </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将存储主进程的进程ID的nginx.pid文件的名称。安装后，可以始终使用pid指令在nginx.conf配置文件中更改文件名。默认情况下，该文件名为prefix / logs / nginx.pid。</span></span><br><span class="line">--pid-path=/run/nginx.pid </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为lock files 的名称设置前缀。安装后，可以始终使用lock_file指令在nginx.conf配置文件中更改该值。默认情况下，该值是prefix / logs / nginx.lock。</span></span><br><span class="line">--lock-path=/run/lock/subsys/nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一个非特权用户的名称，其凭据将由工作进程使用。安装后，始终可以使用用户指令在nginx.conf配置文件中更改名称。默认用户名是nobody。</span></span><br><span class="line">--user=nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置工作进程将使用其凭据的组的名称。安装后，可以始终使用用户指令在nginx.conf配置文件中更改名称。默认情况下，组名称设置为非特权用户的名称。</span></span><br><span class="line">--group=nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面是开启一些特性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> enables the use of asynchronous file I/O (AIO) on FreeBSD and Linux.</span></span><br><span class="line">--with-file-aio </span><br><span class="line">--with-ipv6 </span><br><span class="line">--with-http_ssl_module </span><br><span class="line">--with-http_v2_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用构建ngx_http_realip_module模块的功能，该模块将客户端地址更改为在指定的标头字段中发送的地址。默认情况下未构建此模块。 用例：当本机的nginx处于一个反向代理的后端时获取到真实的用户IP</span></span><br><span class="line">--with-http_realip_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_stream_ssl_preread_module模块，该模块允许从ClientHello消息中提取信息，而无需终止SSL / TLS。默认情况下未构建此模块</span></span><br><span class="line">--with-stream_ssl_preread_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使您能够构建ngx_http_addition_module模块，该模块在response之前和之后添加文本。默认情况下未构建此模块</span></span><br><span class="line">--with-http_addition_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_xslt_module模块，该模块使用一个或多个XSLT样式表转换XML响应。默认情况下未构建此模块。需要libxml2和libxslt库来构建和运行此模块。</span></span><br><span class="line">--with-http_xslt_module=dynamic </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_image_filter_module模块，该模块可以转换JPEG，GIF，PNG和WebP格式的图像。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_image_filter_module=dynamic </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_sub_module模块，该模块通过将一个指定的字符串替换为另一个指定的字符串来修改reponse。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_sub_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_dav_module模块，该模块通过WebDAV协议提供文件管理自动化。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_dav_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_flv_module模块，该模块为Flash Video（FLV）文件提供伪流的服务端支持。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_flv_module</span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_mp4_module模块，该模块为MP4文件提供伪流的服务端支持。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_mp4_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持为不支持“ gzip”编码方法的客户端构建ngx_http_gunzip_module模块，该模块使用“ Content-Encoding：gzip”解压缩responses。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_gunzip_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_gzip_static_module模块，该模块支持发送扩展名为“.gz”的预压缩文件，而不是常规文件。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_gzip_static_module</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许构建ngx_http_random_index_module模块，该模块处理以斜杠（<span class="string">&#x27;/&#x27;</span>）结尾的请求，并在目录中选择一个随机文件作为索引文件。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_random_index_module</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用构建ngx_http_secure_link_module模块。用于检查请求的链接的真实性，保护资源免受未经授权的访问，并限制链接的寿命。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_secure_link_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用构建ngx_http_degradation_module模块的功能。默认情况下未构建此模块。（允许在内存不足的情况下返回204或444码）</span></span><br><span class="line">--with-http_degradation_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_slice_module模块，该模块将请求拆分为子请求，每个子请求返回一定范围的response。该模块可更有效地缓存big response。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_slice_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建ngx_http_stub_status_module模块，该模块提供对基本状态信息的访问。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_stub_status_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建嵌入式Perl模块。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_perl_module=dynamic </span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许构建ngx_http_auth_request_module模块，该模块基于子请求的结果实现客户端授权。默认情况下未构建此模块。</span></span><br><span class="line">--with-http_auth_request_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用POP3 / IMAP4 / SMTP邮件代理服务器。</span></span><br><span class="line">--with-mail=dynamic </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用构建将SSL / TLS协议支持添加到邮件代理服务器的模块的功能。默认情况下未构建此模块。需要OpenSSL库来构建和运行此模块。</span></span><br><span class="line">--with-mail_ssl_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制使用PCRE库。</span></span><br><span class="line">--with-pcre </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用“just-in-time compilation”支持（1.1.12，pcre_jit指令）构建PCRE库。</span></span><br><span class="line">--with-pcre-jit </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建用于通用TCP / UDP代理和负载平衡的流模块。默认情况下未构建此模块。</span></span><br><span class="line">--with-stream=dynamic </span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持构建一个模块，该模块向流模块添加SSL / TLS协议支持。默认情况下未构建此模块。需要OpenSSL库来构建和运行此模块。</span></span><br><span class="line">--with-stream_ssl_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以构建ngx_google_perftools_module模块，以使用Google Performance Tools对nginx工作进程进行性能分析。该模块适用于Nginx开发人员，默认情况下未构建。</span></span><br><span class="line">--with-google_perftools_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> enables the debugging <span class="built_in">log</span>.</span></span><br><span class="line">--with-debug </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将添加到CFLAGS变量的其他参数。在FreeBSD下使用系统PCRE库时，应指定--with-cc-opt =“-I /usr/<span class="built_in">local</span>/include”。如果需要增加select（）支持的文件数量，也可以在此处指定，例如：--with-cc-opt =“-D FD_SETSIZE = 2048”。</span></span><br><span class="line">--with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将在链接期间使用的其他参数。在FreeBSD下使用系统PCRE库时，应指定--with-ld-opt =“-L /usr/<span class="built_in">local</span>/lib”。</span></span><br><span class="line">--with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E</span><br></pre></td></tr></table></figure>


<h2 id="2-2、Nginx的配置系统"><a href="#2-2、Nginx的配置系统" class="headerlink" title="2.2、Nginx的配置系统"></a>2.2、Nginx的配置系统</h2><p>Nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。在 nginx.conf 中，包含若干配置项。每个配置项由配置指令和指令参数 2 个部分构成。指令参数也就是配置指令对应的配置值。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。</p>
<p>指令的参数使用一个或者多个空格或者 TAB 字符与指令分开。指令的参数有一个或者多个 TOKEN 串组成。TOKEN 串之间由空格或者 TAB 键分隔。</p>
<p>TOKEN 串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。</p>
<p>如果一个配置指令的参数全部由简单字符串构成，也就是不包含复合配置块，那么我们就说这个配置指令是一个简单配置项，否则称之为复杂配置项。例如下面这个是一个简单配置项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br></pre></td></tr></table></figure>
<p>对于简单配置，配置项的结尾使用分号结束。对于复杂配置项，包含多个 TOKEN 串的，一般都是简单 TOKEN 串放在前面，复合配置块一般位于最后，而且其结尾，并不需要再添加分号。例如下面这个复杂配置项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /home/jizhao/nginx-book/build/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令上下文"><a href="#指令上下文" class="headerlink" title="指令上下文"></a>指令上下文</h3><p>nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>
<p>当前 Nginx 支持的几个指令上下文：</p>
<ul>
<li>main: Nginx 在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</li>
<li>http: 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用gzip进行压缩等。</li>
<li>server: http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server，每个 server 通过监听的地址来区分。</li>
<li>location: http 服务中，某些特定的URL对应的一系列配置项。</li>
<li>mail: 实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</li>
</ul>
<h3 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">user nobody; # a directive in the &#x27;main&#x27; context</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    # configuration of connection processing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # Configuration specific to HTTP and affecting all virtual servers  </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # configuration of HTTP virtual server 1       </span><br><span class="line">        location /one &#123;</span><br><span class="line">            # configuration for processing URIs starting with &#x27;/one&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        location /two &#123;</span><br><span class="line">            # configuration for processing URIs starting with &#x27;/two&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        # configuration of HTTP virtual server 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    # Configuration specific to TCP/UDP and affecting all virtual servers</span><br><span class="line">    server &#123;</span><br><span class="line">        # configuration of TCP virtual server 1 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3、配置文件详解"><a href="#2-3、配置文件详解" class="headerlink" title="2.3、配置文件详解"></a>2.3、配置文件详解</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">定义Nginx运行的用户和用户组</span></span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">nginx进程数，建议设置为等于CPU总核心数。</span></span><br><span class="line">worker_processes 8;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line">error_log /usr/local/nginx/logs/error.log info;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进程pid文件</span></span><br><span class="line">pid /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定进程可以打开的最大描述符：数目</span></span><br><span class="line"><span class="meta">#</span><span class="bash">工作模式与连接数上限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（<span class="built_in">ulimit</span> -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与<span class="built_in">ulimit</span> -n 的值保持一致。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br><span class="line">    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    #补充说明：</span><br><span class="line">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    #A）标准事件模型</span><br><span class="line">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">    #B）高效事件模型</span><br><span class="line">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br><span class="line">    worker_connections 65535;</span><br><span class="line"></span><br><span class="line">    #keepalive超时时间。</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br><span class="line">    #分页大小可以用命令getconf PAGESIZE 取得。</span><br><span class="line">    #[root@web001 ~]# getconf PAGESIZE</span><br><span class="line">    #4096</span><br><span class="line">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">    open_file_cache max=65535 inactive=60s;</span><br><span class="line"></span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line"></span><br><span class="line">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    </span><br><span class="line">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误.</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include mime.types;</span><br><span class="line"></span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #默认编码</span><br><span class="line">    #charset utf-8;</span><br><span class="line"></span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line"></span><br><span class="line">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line"></span><br><span class="line">    #设定通过nginx上传文件的大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">     </span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line"></span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;    #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;    #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;    #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #开启限制IP连接数的时候需要使用</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #负载均衡配置</span><br><span class="line">    upstream jh.w3cschool.cn &#123;</span><br><span class="line">     </span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line"></span><br><span class="line">        #nginx的upstream目前支持4种方式的分配</span><br><span class="line">        #1、轮询（默认）</span><br><span class="line">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        #2、weight</span><br><span class="line">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    server 192.168.0.14 weight=10;</span><br><span class="line">        #    server 192.168.0.15 weight=10;</span><br><span class="line">        #&#125;</span><br><span class="line">        #2、ip_hash</span><br><span class="line">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 192.168.0.14:88;</span><br><span class="line">        #    server 192.168.0.15:80;</span><br><span class="line">        #&#125;</span><br><span class="line">        #3、fair（第三方）</span><br><span class="line">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server server1;</span><br><span class="line">        #    server server2;</span><br><span class="line">        #    fair;</span><br><span class="line">        #&#125;</span><br><span class="line">        #4、url_hash（第三方）</span><br><span class="line">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server squid1:3128;</span><br><span class="line">        #    server squid2:3128;</span><br><span class="line">        #    hash $request_uri;</span><br><span class="line">        #    hash_method crc32;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #tips:</span><br><span class="line">        #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 127.0.0.1:9090 down;</span><br><span class="line">        #    server 127.0.0.1:8080 weight=2;</span><br><span class="line">        #    server 127.0.0.1:6060;</span><br><span class="line">        #    server 127.0.0.1:7070 backup;</span><br><span class="line">        #&#125;</span><br><span class="line">        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><span class="line"></span><br><span class="line">        #每个设备的状态设置为:</span><br><span class="line">        #1.down表示单前的server暂时不参与负载</span><br><span class="line">        #2.weight为weight越大，负载的权重就越大。</span><br><span class="line">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.w3cschool.cn w3cschool.cn;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root /data/www/w3cschool;</span><br><span class="line"></span><br><span class="line">        #对******进行负载均衡</span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #日志格式设定</span><br><span class="line">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">        #$remote_user：用来记录客户端用户名称；</span><br><span class="line">        #$time_local： 用来记录访问时间与时区；</span><br><span class="line">        #$request： 用来记录请求的url与http协议；</span><br><span class="line">        #$status： 用来记录请求状态；成功是200，</span><br><span class="line">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class="line">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class="line">        log_format access &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">        &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">        &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;;</span><br><span class="line">         </span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class="line">         </span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             </span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             </span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class="line">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file confpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class="line">        pdf|xls|mp3|wma)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4、nginx-双机主备容灾"><a href="#2-4、nginx-双机主备容灾" class="headerlink" title="2.4、nginx 双机主备容灾"></a>2.4、nginx 双机主备容灾</h2><p>参见次文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liu1160848595/article/details/104613727">nginx+keepalived实现双机主备容灾</a></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/nginx/">Nginx 入门指南</a></p>
<p><a target="_blank" rel="noopener" href="https://nginx.org/en/docs/">nginx官网</a></p>
<h1 id="Nginx架构"><a href="#Nginx架构" class="headerlink" title="Nginx架构"></a>Nginx架构</h1><p>本文翻译于 <a target="_blank" rel="noopener" href="http://www.aosabook.org/en/nginx.html">http://www.aosabook.org/en/nginx.html</a></p>
<blockquote>
<p>注：这篇文章 或许是 2015年的文章</p>
</blockquote>
<p>nginx（发音为“enginex”）是由俄罗斯软件工程师igorsysoev编写的免费开源web服务器。nginx自2004年公开发布以来，一直致力于高性能、高并发性和低内存使用。除了web服务器的功能之外，还有诸如负载平衡、缓存、访问(access)和带宽控制以及与各种应用程序有效集成的能力，nginx成为现代网站架构的一个不错的选择。目前nginx是互联网上第二流行的开源web服务器。</p>
<h2 id="1、为什么高并发很重要？"><a href="#1、为什么高并发很重要？" class="headerlink" title="1、为什么高并发很重要？"></a>1、为什么高并发很重要？</h2><p>现在互联网是如此的广泛和无处不在，很难想象30年前它还不存在（万维网于1991年诞生）。从基于NCSA和apache web服务器的简单HTML生成可点击文本，到全球超过20亿用户使用的始终在线的通信媒介，它已经有了很大的发展。随着永久连接的个人电脑、移动设备和最近的平板电脑的普及，互联网的格局正在迅速变化，整个经济体都已经数字化。在线服务变得更加精细，明显偏向于即时可用的实时信息和娱乐。运营在线业务的安全方面也发生了重大变化。相应地，现在的网站比以前复杂得多，通常需要更多的工程设计来实现健壮性和可伸缩性。</p>
<p>对于网站架构师来说，最大的挑战之一就是并发性。自web服务出现以来，并发性的水平一直在不断提高。一个受欢迎的网站能够同时为数十万甚至数百万用户提供服务，这并不少见。十年前，并发的主要原因是使用ADSL或拨号连接的客户端速度慢。现在，并发是由移动客户端和更新的应用程序架构的组合引起的，这些架构通常基于保持一个持久的连接，允许客户端通过新闻、tweet、好友feed等进行更新。另一个导致并发性增加的重要因素是现代浏览器行为的改变，它同时打开4到6个网站连接，以提高页面加载速度。</p>
<p>为了说明 slow client 的问题，设想一个简单的基于Apache的web服务器，它产生一个相对较短的100kb response —— 一个带有文本或图像的web页面。生成或检索此页面只需几秒钟，但将其传输到带宽为80kbps（10kb/s）的客户端需要10秒。从本质上讲，web服务器将相对快速地获取100KB的内容，然后在释放连接之前，它将忙碌10秒钟，缓慢地将这些内容发送到客户端。现在假设您有1000个同时连接的客户机，他们请求类似的内容。如果每个 client 只分配1 MB的额外内存，则会产生1000 MB（约1 GB）的额外内存，专门用于为1000个 client 提供100 KB的内容。实际上，一个典型的基于Apache的web服务器通常为每个连接分配超过1MB的额外内存，遗憾的是，几十kbps仍然是移动通信的有效速度。尽管在某种程度上，通过增加操作系统内核套接字缓冲区的大小，将内容发送到速度较慢的客户端的情况可能会有所改善，但这并不是解决问题的通用方法，而且可能会产生不良的副作用。</p>
<p>对于持久连接，处理并发性的问题更为突出，因为 为了避免与建立新的HTTP连接相关的延迟，客户端将保持连接，并且对于每个连接的客户端，web服务器都会分配一定数量的内存。</p>
<p>因此，为了处理与不断增长的受众相关的工作负载，从而提高并发级别，并能够持续地这样做，一个网站应该基于一些非常有效的构建块。虽然等式的其他部分，如硬件（CPU、内存、磁盘）、网络容量、应用程序和数据存储架构显然很重要，但客户端连接是在web服务器软件中被接受和处理的。因此，web服务器应该能够随着每秒同时连接和请求数量的增加而非线性扩展。</p>
<h3 id="apache不合适吗？"><a href="#apache不合适吗？" class="headerlink" title="apache不合适吗？"></a>apache不合适吗？</h3><p>Apache是一种至今仍在互联网上占主导地位的web服务器软件，它的起源于20世纪90年代初。最初，它的体系结构与当时的操作系统和硬件相匹配，也符合Internet的现状，即网站通常是运行单个Apache实例的独立物理服务器。到了21世纪初，很明显，独立的web服务器模型不容易被复制以满足不断增长的web服务的需求。虽然Apache为未来的发展提供了坚实的基础，但它是为每个新的连接生成一个自己的副本，这是不适合网站的非线性可伸缩性的。最终，Apache成为了一个通用的web服务器，专注于具有许多不同的特性、各种第三方扩展以及对几乎任何类型的web应用程序开发的普遍适用性。然而，没有什么是没有代价的，在一个软件中拥有如此丰富和通用的工具组合的缺点是，由于每个连接的CPU和内存使用量增加，扩展性降低。</p>
<p>因此，当服务器硬件、操作系统和网络资源不再是网站增长的主要制约因素时，世界各地的web开发人员开始寻找运行web服务器的更有效的方法。大约十年前，著名的软件工程师丹尼尔·凯格尔（Daniel Kegel）宣称，“现在是时候让web服务器同时处理一万个客户端了”，并预言了我们现在所说的互联网云服务。Kegel的 C10K 宣言激发了许多人试图解决web服务器优化问题以同时处理大量客户端，nginx是其中最成功的一个。</p>
<p>为了解决10000个并发连接的c10k问题，nginx在编写时考虑了一种不同的架构，这种架构在并发连接数和每秒请求数方面都更适合于非线性伸缩。nginx是基于事件的，因此它不遵循Apache为每个web页面请求生成新进程或线程的风格。最终的结果是，即使负载增加，内存和CPU的使用仍然是可管理的。nginx现在可以在具有典型硬件的服务器上提供数万个并发连接。</p>
<p>当nginx的第一个版本发布时，它本来打算与Apache一起部署，这样静态内容（如HTML、CSS、JavaScript和图像）由nginx处理，从而减轻基于Apache的应用服务器的并发和延迟处理。在其开发过程中，nginx通过使用FastCGI、uswgi或SCGI协议增加了与应用程序的集成，以及与memcached等分布式内存对象缓存系统的集成。还添加了其他有用的功能，如带有负载平衡和缓存的反向代理。这些附加的特性将nginx塑造成一个高效的工具组合，可以在此基础上构建可伸缩的web基础设施。</p>
<p>2012年2月，Apache2.4.x分支向公众发布。尽管Apache的最新版本增加了新的multi-processing core模块和新的 proxy 模块，旨在增强可伸缩性和性能，但现在要判断它的性能、并发性和资源利用率是否与纯事件驱动的web服务器不相上下，甚至更好，还为时过早。不过，在Apache新版本的服务器上，Apache的典型配置仍然可以更好地解决它的瓶颈问题。</p>
<h3 id="使用nginx还有更多的优势吗？"><a href="#使用nginx还有更多的优势吗？" class="headerlink" title="使用nginx还有更多的优势吗？"></a>使用nginx还有更多的优势吗？</h3><p>以高性能和高效率处理高并发性一直是部署nginx的关键好处。然而，现在还有更有趣的好处。</p>
<p>在过去的几年里，web架构师已经接受了将他们的应用程序基础设施与web服务器分离的思想。然而，以前以LAMP（Linux、Apache、MySQL、PHP、Python或Perl）形式存在的网站，现在可能不仅仅是一个基于LEMP的网站（“E”代表“Engine x”），而且越来越频繁地成为将web服务器推到基础设施的边缘并以不同的方面集成相同或经过改进的应用程序和数据库工具集。</p>
<p>nginx非常适合这一点，因为它提供了必要的关键特性，可以方便地减轻并发、延迟处理、SSL（安全套接字层）、静态内容、压缩和缓存、连接和请求限制，甚至HTTP媒体流从应用层传输到更高效的边缘web服务器层。它还允许直接与memcached/Redis或其他“NoSQL”解决方案集成，以提高服务于大量并发用户时的性能。</p>
<p>随着近年来开发工具包和编程语言的广泛使用，越来越多的公司正在改变他们的应用程序开发和部署习惯。nginx已经成为这些不断变化的模式中最重要的组成部分之一，它已经帮助许多公司在预算内快速启动和开发web服务。</p>
<p>nginx的第一行写于2002年。2004年，它根据两条BSD许可证向公众发布。从那以后，nginx用户的数量一直在增长，他们提供想法，提交bug报告、建议和观察，这些都对整个社区非常有帮助和帮助。</p>
<p>nginx代码库是原创的，完全是用C编程语言从头开始编写的。nginx已经移植到许多架构和操作系统上，包括Linux、FreeBSD、Solaris、macosx、AIX和microsoftwindows。nginx有自己的库，除了zlib、PCRE和OpenSSL之外，nginx有自己的库，如果不需要或者由于潜在的许可冲突，可以选择从构建中排除。</p>
<p>关于nginx的Windows版本。虽然nginx在Windows环境下工作，但nginx的Windows版本更像是一个概念证明，而不是一个功能齐全的端口。nginx和Windows内核体系结构有一定的局限性，目前不能很好地进行交互。nginx for windows版本的已知问题包括并发连接数量大大减少、性能下降、没有缓存和带宽管理。nginx for windows的未来版本将更接近主流功能。</p>
<h2 id="2、Nginx架构概述"><a href="#2、Nginx架构概述" class="headerlink" title="2、Nginx架构概述"></a>2、Nginx架构概述</h2><p>传统的处理并发连接的 基于进程或线程的模型 包括用单独的进程或线程处理每个连接，以及阻塞网络或输入/输出操作。根据应用程序的不同，它可能在内存和CPU消耗方面非常低效。生成单独的进程或线程需要准备新的运行时环境，包括分配堆和堆栈内存，以及创建新的执行上下文。创建这些项也要花费额外的CPU时间，这最终会由于过度上下文切换时的线程抖动而导致性能低下。所有这些复杂的情况都体现在像Apache这样的旧的web服务器架构中，这是在提供一组广泛适用的功能和优化服务器资源使用之间的权衡。</p>
<p>从一开始，nginx就是一个专门的工具，在实现网站动态增长的同时，实现更高的性能 和更高效的服务器资源使用，因此它遵循了不同的模式。它实际上是受到了各种操作系统中基于事件的高级机制的不断发展的启发。结果是一个模块化的、事件驱动的、异步的、单线程的、非阻塞的体系结构，它成为NGNIX代码的基础。</p>
<p>nginx大量使用多路复用和事件通知，并将特定的任务分配给不同的进程。连接是在一个高效的运行循环中在一个称为worker的有限数量的单线程进程中处理的。在每个worker中nginx每秒可以处理数千个并发连接和请求。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>nginx worker代码包括 core 和 functional 模块。nginx的 core 负责维护一个紧密的运行循环，并在请求处理的每个阶段执行模块代码的适当部分。模块构成了表示层和应用层的大部分功能。模块读写网络和存储、转换内容、执行出站(outbound)筛选、应用服务器端的 include 操作 并在代理激活时将请求传递给上游服务器。</p>
<p>nginx的模块化架构通常允许开发人员在不修改nginx core的情况下扩展web服务器的一组特性。nginx模块的具体形式略有不同，即core modules, event modules, phase handlers, protocols, variable handlers, filters, upstreams and load balancers。此外，nginx不支持动态加载的模块；也就是说，模块是在构建阶段与core一起编译的。但是，对可加载模块和ABI的支持计划在未来的主要版本中使用。</p>
<p>在处理与接受、处理和管理网络连接和内容检索相关的各种操作时，nginx在基于Linux、Solaris和BSD的操作系统（如kqueue、epoll和event ports）中使用事件通知机制和大量磁盘I/O性能增强。目标是向操作系统提供尽可能多的提示，以获得入站和出站流量、磁盘操作、读写套接字、超时等的及时异步反馈。nginx运行的每一个基于Unix的操作系统都对多路复用和高级I/O操作的不同方法进行了大量优化。</p>
<p><img src="https://www.aosabook.org/images/nginx/architecture.png" alt="img"></p>
<h3 id="Workers-Model"><a href="#Workers-Model" class="headerlink" title="Workers Model"></a>Workers Model</h3><p>如前所述，nginx并不为每个连接生成一个进程或线程。相反，工作进程接受来自共享“listen”套接字的新请求，并在每个工作进程内执行高效的运行循环，以在每个工作进程内处理数千个连接。nginx中没有专门的仲裁或分发控制到worker的连接；这项工作是由OS内核机制完成的。启动时，将创建一组初始侦听套接字。然后，worker在处理HTTP请求和响应时，不断地接受、读取和写入套接字。</p>
<p>run-loop 是nginx worker程序代码中最复杂的部分。它包括所有的内部调用，并且严重依赖异步任务处理的思想。异步操作通过模块化、事件通知、广泛使用回调函数和微调计时器来实现。总的来说，关键原则是尽可能不阻塞。nginx仍然可以阻塞的唯一情况是没有足够的磁盘存储性能来支持工作进程。</p>
<p>因为nginx不为每个连接fork一个进程或线程，内存使用在绝大多数情况下都是非常保守和高效的。nginx也节省了CPU周期，因为进程或线程没有持续的create-destroy模式。nginx所做的是检查网络和存储的状态，初始化新的连接，将它们添加到运行循环中，然后异步处理直到完成，此时连接被释放并从运行循环中删除。结合对syscalls的谨慎使用和对池和slab内存分配器等接口的精确实现，nginx通常甚至在极端工作负载下也能实现中等到较低的CPU使用率。</p>
<p>因为nginx产生几个worker来处理连接，所以它可以很好地跨多个核心进行扩展。一般来说，每个核心都有一个独立的worker可以充分利用多核架构，并防止线程抖动和锁定。没有资源匮乏，因为资源控制机制被隔离在单线程工作进程中。此模型还允许跨物理存储设备实现更高的可扩展性，更高的磁盘利用率，并避免磁盘I/O阻塞。因此，通过多个 worker 共享工作负载，可以更有效地利用服务器资源。</p>
<p>对于某些磁盘使用和CPU负载模式，应该调整nginx工作线程的数量。这里有些基本规则，系统管理员应该为他们的工作负载尝试一些配置。一般建议如下：如果负载模式是CPU密集型的，例如，处理大量TCP/IP、执行SSL或压缩，则nginx worker的数量应与CPU core的数量相匹配；如果负载主要是磁盘I/O的，例如，从存储服务处理不同的内容集，或者有大量代理，worker的数量可能是核心数量的1.5到2倍。一些工程师根据单个存储单元的数量来选择worker的数量，尽管这种方法的效率取决于磁盘存储的类型和配置。</p>
<p>nginx的开发人员在即将发布的版本中要解决的一个主要问题是如何避免磁盘I/O上的大部分阻塞。目前，如果没有足够的存储性能来服务于某个特定worker生成的磁盘操作，那么该worker可能仍然会阻塞对磁盘的读/写操作。存在许多机制和配置文件指令来减轻这种磁盘I/O阻塞情况。最值得注意的是，sendfile和AIO等选项的组合通常会为磁盘性能带来很大的空间。nginx的安装应该根据数据集、nginx可用的内存量以及底层存储架构来计划。</p>
<p>现有worker模型的另一个问题与对嵌入式脚本的有限支持有关。首先，在标准nginx发行版中，只支持嵌入Perl脚本。对此有一个简单的解释：关键问题是嵌入式脚本有可能在任何操作上阻塞或意外退出。这两种行为都会立即导致工作线程被挂起的情况，同时影响数千个连接。我们计划做更多的工作，使nginx的嵌入式脚本更简单、更可靠，并适合更广泛的应用程序。</p>
<h3 id="nginx进程角色"><a href="#nginx进程角色" class="headerlink" title="nginx进程角色"></a>nginx进程角色</h3><p>nginx在内存中运行多个进程；有一个主进程和多个工作进程。还有一些特殊用途的进程，特别是cache loader 和cache manager。nginx版本1.x中的所有进程都是单线程的。所有进程主要使用共享内存机制进行进程间通信。主进程以root用户身份运行。cache loader, cache manager和worker 作为非特权用户运行。</p>
<p>Master 进程负责以下任务：</p>
<ul>
<li>reading and validating configuration</li>
<li>creating, binding and closing sockets</li>
<li>starting, terminating and maintaining the configured number of <code>worker</code> processes</li>
<li>reconfiguring without service interruption</li>
<li>controlling non-stop binary upgrades (starting new binary and rolling back if necessary)</li>
<li>re-opening log files</li>
<li>compiling embedded Perl scripts</li>
</ul>
<p>工作进程接受、handle 和 process 来自客户机的连接，提供反向代理和过滤功能，并执行nginx所能完成的几乎所有其他事情。在监控nginx实例的行为时，系统管理员应该关注worker，因为它们是反映web服务器实际日常操作的进程。</p>
<p>cache loader 进程负责检查磁盘上的缓存项，并用缓存元数据填充nginx的内存数据库。本质上，cache loader 准备nginx实例来处理已经存储在磁盘上的文件，这些文件存储在一个特别分配的目录结构中。它遍历目录，检查缓存内容元数据，更新共享内存中的相关条目，然后在所有内容都清理干净并可以使用时退出。</p>
<p>cache manager  主要负责缓存过期和失效。在nginx正常运行期间，它保留在内存中，如果发生故障，它将由主进程重新启动。</p>
<h3 id="nginx缓存简介"><a href="#nginx缓存简介" class="headerlink" title="nginx缓存简介"></a>nginx缓存简介</h3><p>nginx中的缓存是在文件系统上以分层数据存储的形式实现的。Cache key是可配置的，可以使用不同的request-specific 参数来控制进入缓存的内容。缓存键和缓存元数据存储在共享内存段中，cache loader, cache manager and <code>worker</code>可以访问这些内存段。目前除了操作系统的虚拟文件系统机制自带的优化之外，没有任何文件的内存缓存。每个缓存的响应都放在文件系统的不同文件中。层次结构（levels and naming details）通过nginx配置指令进行控制。将响应写入缓存目录结构时，文件的路径和名称将从代理URL的MD5哈希派生。</p>
<p>将内容放入缓存的过程如下：nginx从上游服务器读取响应时，首先将内容写入缓存目录结构之外的临时文件。nginx完成处理请求后，会重命名临时文件并将其移动到缓存目录。如果用于代理的临时文件目录位于另一个文件系统上，则会复制该文件，因此建议将临时目录和缓存目录保留在同一个文件系统上。当需要显式清除文件时，从缓存目录结构中删除文件也是相当安全的。nginx的第三方扩展使得远程控制缓存内容成为可能，并且计划在主发行版中集成此功能的更多工作。</p>
<h2 id="3、Nginx-Configuration"><a href="#3、Nginx-Configuration" class="headerlink" title="3、Nginx Configuration"></a>3、Nginx Configuration</h2><p>nginx的配置系统的灵感来自igor Sysoev对Apache的体验。他的主要观点是，一个可伸缩的配置系统对于web服务器是必不可少的。在维护具有大量virtual servers, directories, locations and datasets的大型复杂配置时，会遇到主要的缩放问题。在一个相对较大的web设置中，如果不能在应用程序级别由系统工程师自己来完成，这可能是一场噩梦。</p>
<p>因此，nginx配置旨在简化日常操作，并为进一步扩展web服务器配置提供一种简单的方法。</p>
<p>nginx配置保存在许多纯文本文件中，这些文件通常位于<code>/usr/local/etc/nginx</code>或<code>/etc/nginx</code>中。主配置文件通常称为<code>nginx.conf</code>。为了保持它的整洁，部分配置可以放在单独的文件中，这些文件可以自动包含在主文件中。但是，这里应该注意到nginx目前不支持Apache风格的分布式配置（即<code>.htaccess</code>文件）。所有与nginx web服务器行为相关的配置都应该集中在一组配置文件集中。</p>
<p>配置文件最初由主进程读取和验证。nginx配置的编译只读形式可用于工作进程，因为它们是从主进程派生出来的。配置结构由通常的虚拟内存管理机制自动共享。</p>
<p>nginx配置对于main<code>, </code>http<code>, </code>server<code>, </code>upstream<code>, </code>location（以及用于mail proxy 的 <code>mail</code> ）有几个不同的上下文。上下文永远不会重叠。例如，不存在将 location 块放在指令的 main 块中这样的事情。此外，为了避免不必要的歧义，没有任何类似“全局web服务器”的配置。nginx的配置是干净和逻辑的，允许用户维护包含数千条指令的复杂配置文件。在一次私人谈话中，Sysoev说：“全局服务器配置中的 Locations, directories, and other blocks 是我在Apache中不喜欢的特性，所以这就是为什么它们从未在nginx中实现过的原因。”</p>
<p>配置语法、格式和定义遵循所谓的C风格约定。这种制作配置文件的特殊方法已经被各种开源和商业软件应用程序使用。通过设计，C风格的配置非常适合嵌套描述，逻辑性强，易于创建、读取和维护，受到许多工程师的喜爱。nginx的C风格配置也可以轻松实现自动化。</p>
<p>虽然nginx指令的某些部分类似于Apache配置的某些部分，但是设置nginx实例则是一种完全不同的体验。例如，nginx支持重写(rewrite)规则，但它需要管理员手动调整旧版Apache重写配置以匹配nginx样式。重写引擎的实现也不同。</p>
<p>一般来说，nginx设置还提供了对几种原始机制的支持，这些机制在精简web服务器配置时非常有用。简单地介绍一下 variables 和 <code>try_files</code> 指令是有意义的，它们对nginx来说有点独特。nginx中的变量是为了提供一种更强大的机制来控制web服务器的运行时配置。变量经过优化以快速评估，并在内部预先编译为索引。求值是按需进行的；也就是说，一个变量的值通常只计算一次，并在特定请求的生命周期内进行缓存。变量可以与不同的配置指令一起使用，为描述条件请求处理行为提供了额外的灵活性。</p>
<p><code>try_files</code>指令最初的目的是以更恰当的方式逐步替换条件<code>if</code>配置语句，它被设计成针对不同的URI到内容映射快速有效地 try/match。总的来说，<code>try_files</code> 指令工作得很好，建议读者彻底检查 try_files 指令，并在适用的情况下使用它。</p>
<h2 id="4、nginx内部构件"><a href="#4、nginx内部构件" class="headerlink" title="4、nginx内部构件"></a>4、nginx内部构件</h2><p>如前所述，nginx代码库由一个核心和多个模块组成。NGiNX的核心是提供Web服务器、Web和邮件反向代理功能的基础；它支持底层网络协议的使用，建立必要的运行时环境，并确保不同模块之间的无缝交互。然而，大多数协议和应用程序特定的特性是由nginx模块完成的，而不是核心。</p>
<p>在内部，nginx通过一个管道或 chain 应用模块来处理连接。换句话说，对于每个操作，都有一个模块在做相关的工作；例如，压缩、修改内容、执行服务端的 include、通过FastCGI或uwsgi协议与上游应用服务器通信，或者与memcached通信。</p>
<p>有几个nginx模块位于核心和真正的“功能”模块之间。这些模块是http和mail。这两个模块在核心组件和较低级别组件之间提供了额外的抽象级别。在这些模块中，处理与相应的应用层协议（如HTTP、SMTP或IMAP）相关联的事件序列。结合nginx核心，这些上层模块负责维护对各个功能模块的正确调用顺序。虽然HTTP协议目前是作为HTTP模块的一部分实现的，但是由于需要支持SPDY之类的其他协议，未来有计划将其分离成一个功能模块（参见“<a target="_blank" rel="noopener" href="http://www.chromium.org/spdy/spdy-whitepaper">SPDY：一个快速web的实验性协议</a>”）。</p>
<p>功能模块可分为event modules, phase handlers, output filters, variable handlers, protocols, upstreams and load balancers.。虽然event模块和Protocol也用于邮件，但这些模块中的大多数都是对nginx的HTTP功能的补充。event 模块提供了一种特定的依赖于操作系统的事件通知机制，如kqueue或epoll。nginx使用的事件模块取决于操作系统功能和构建配置。Protocol模块允许nginx通过HTTPS、TLS/SSL、SMTP、POP3、IMAP进行通信。</p>
<h3 id="典型的HTTP请求处理周期"><a href="#典型的HTTP请求处理周期" class="headerlink" title="典型的HTTP请求处理周期"></a><strong>典型的HTTP请求处理周期</strong></h3><ol>
<li>Client sends HTTP request.</li>
<li>nginx core chooses the appropriate phase handler based on the configured location matching the request.</li>
<li>If configured to do so, a load balancer picks an upstream server for proxying.</li>
<li>Phase handler does its job and passes each output buffer to the first filter.</li>
<li>First filter passes the output to the second filter.</li>
<li>Second filter passes the output to third (and so on).</li>
<li>Final response is sent to the client.</li>
</ol>
<p>nginx模块调用是可定制的。它通过使用指向可执行函数的指针的一系列回调来执行。然而，这样做的缺点是，这可能会给想要编写自己模块的程序员带来很大的负担，因为他们必须确切地定义模块应该如何运行以及何时运行。nginx api和开发人员的文档都得到了改进，并提供了更多的可用性来缓解这一问题。</p>
<h3 id="attach-模块的示例"><a href="#attach-模块的示例" class="headerlink" title="attach 模块的示例"></a><strong>attach 模块的示例</strong></h3><ul>
<li>Before the configuration file is read and processed</li>
<li>对于出现 location 和 server 的每个配置指令</li>
<li>When the main configuration is initialized</li>
<li>When the server (i.e., host/port) is initialized</li>
<li>When the server configuration is merged with the main configuration</li>
<li>When the location configuration is initialized or merged with its parent server configuration</li>
<li>When the master process starts or exits</li>
<li>When a new worker process starts or exits</li>
<li>When handling a request</li>
<li>When filtering the response header and the body</li>
<li>When picking, initiating and re-initiating a request to an upstream server</li>
<li>When processing the response from an upstream server</li>
<li>When finishing an interaction with an upstream server</li>
</ul>
<h3 id="在worker中，导致生成响应的-run-loop-的操作序列"><a href="#在worker中，导致生成响应的-run-loop-的操作序列" class="headerlink" title="在worker中，导致生成响应的 run-loop 的操作序列"></a><strong>在worker中，导致生成响应的 run-loop 的操作序列</strong></h3><ol>
<li>Begin <code>ngx_worker_process_cycle()</code>.</li>
<li>Process events with OS specific mechanisms (such as <code>epoll</code> or <code>kqueue</code>).</li>
<li>Accept events and dispatch the relevant actions.</li>
<li>Process/proxy request header and body.</li>
<li>Generate response content (header, body) and stream it to the client.</li>
<li>Finalize request.</li>
<li>Re-initialize timers and events.</li>
</ol>
<p>run-loop本身（步骤5和步骤6）确保增量生成响应并将其流式传输到客户端</p>
<h3 id="处理HTTP请求的详细视图"><a href="#处理HTTP请求的详细视图" class="headerlink" title="处理HTTP请求的详细视图"></a><strong>处理HTTP请求的详细视图</strong></h3><ol>
<li>Initialize request processing.</li>
<li>Process header.</li>
<li>Process body.</li>
<li>Call the associated handler.</li>
<li>Run through the processing phases.</li>
</ol>
<p>这就把我们带到了phases。当nginx处理一个HTTP请求时，它将通过许多processing phases来传递它。在每个阶段都有要调用的处理程序。一般来说，阶段处理程序处理一个请求并产生相关的输出。阶段处理程序附加到配置文件中定义的位置。</p>
<p>Phase handlers 通常做四件事：获取location配置、生成适当的响应、发送header 和发送 body。handler有一个参数：描述请求的特定结构。请求结构有很多关于客户机请求的有用信息，比如请求方法、URI和 header。</p>
<p><strong>当读取HTTP请求头时，nginx会查找相关联的虚拟服务器配置。如果找到虚拟服务器，请求将经过六个阶段：</strong></p>
<ol>
<li>server rewrite phase</li>
<li>location phase</li>
<li>location rewrite phase (which can bring the request back to the previous phase)</li>
<li>access control phase</li>
<li>try_files phase</li>
<li>log phase</li>
</ol>
<p>为了响应请求生成必要的内容，nginx将请求传递给合适的content handler。根据具体的location配置，nginx可能会先尝试所谓的无条件处理程序，如perl、proxy_pass、flv、mp4等。如果请求与上述任何内容处理程序不匹配，它将由以下处理程序之一选择：random index、index、autoindex、gzip_static、static。</p>
<p>可以在nginx文档中找到 Indexing 模块的详细信息，但是这些模块处理的是带有尾部斜杠的请求。如果mp4或autoindex这样的专用模块不合适，那么内容将被认为只是磁盘上的一个文件或目录（即静态的），并由 static 内容处理程序提供服务。对于一个目录，它会自动重写URI，以便尾部的斜杠始终存在（然后发出HTTP重定向）</p>
<p>然后将内容处理程序的内容传递给过滤器。过滤器也附加到 location，并且可以为一个location 配置多个过滤器。过滤器执行操作处理程序生成的输出的任务。过滤器的执行顺序在编译时确定。对于现成的过滤器，它是预定义的，对于第三方过滤器，它可以在构建阶段配置。在现有的nginx实现中，过滤器只能进行出站更改，目前没有编写和附加过滤器来进行输入内容转换的机制。输入过滤将出现在nginx的未来版本中。</p>
<p>过滤器遵循特定的设计模式。一个过滤器被调用，开始工作，并调用下一个过滤器，直到调用链中的最后一个过滤器。然后，nginx完成响应。过滤器不必等待前一个过滤器完成。链中的下一个过滤器可以在上一个过滤器的输入可用时立即开始自己的工作（在功能上很像Unix管道）。反过来，生成的输出响应可以在接收来自上游服务器的整个响应之前传递给客户机。</p>
<p>有header 过滤器和 body 过滤器；nginx将响应的头和主体分别提供给相关的过滤器。</p>
<p><strong>A header filter consists of three basic steps:</strong></p>
<ol>
<li>Decide whether to operate on this response.</li>
<li>Operate on the response.</li>
<li>Call the next filter.</li>
</ol>
<p><strong>Body filters transform the generated content. Examples of body filters include:</strong></p>
<ul>
<li><p>server-side includes</p>
</li>
<li><p>XSLT filtering</p>
</li>
<li><p>image filtering (for instance, resizing images on the fly)</p>
</li>
<li><p>charset modification</p>
</li>
<li><p><code>gzip</code> compression</p>
</li>
<li><p>chunked encoding</p>
<p>在过滤器链之后，将响应传递给 writer。除了 writer 之外，还有一些附加的特殊用途过滤器，即 copy 过滤器和postpone 过滤器。copy 过滤器负责用可能存储在代理临时目录中的相关响应内容填充内存缓冲区。postpone过滤器用于子请求。</p>
</li>
</ul>
<p>子请求是 request/response 程序的一种非常重要的机制。子请求也是nginx最强大的方面之一。使用子请求 nginx可以从不同于客户端最初请求的URL返回结果。一些web框架称之为内部重定向。然而，nginx更进一步，不仅过滤器可以执行多个子请求并将输出组合成一个响应，而且子请求也可以嵌套和分层。子请求可以执行自己的子请求，子请求可以启动子子子请求。子请求可以映射到硬盘、其他处理程序或上游服务器上的文件。子请求对于根据原始响应中的数据插入附加内容非常有用。例如，SSI（服务器端 include）模块使用筛选器来解析返回文档的内容，然后用指定url的内容替换include指令。或者，它可以是一个过滤器的例子，它将文档的整个内容视为要检索的URL，然后将新文档附加到URL本身。</p>
<p>Upstream and load balancers也值得简要介绍。upstream 用于反向代理(<code>proxy_pass</code> handler) 内容处理程序。上游模块主要准备将请求发送到上游服务器（或“后端”）并接收来自上游服务器的响应。这里没有对输出过滤器的调用。上游模块所做的是设置在上游服务器准备好写入和读取时调用的回调。存在实现以下功能的回调：</p>
<ul>
<li>Crafting a request buffer (or a chain of them) to be sent to the upstream server</li>
<li>Re-initializing/resetting the connection to the upstream server (which happens right before creating the request again)</li>
<li>Processing the first bits of an upstream response and saving pointers to the payload received from the upstream server</li>
<li>Aborting requests (which happens when the client terminates prematurely)</li>
<li>Finalizing the request when nginx finishes reading from the upstream server</li>
<li>Trimming the response body (e.g. removing a trailer)</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在单个nginx worker中实现的内存分配机制在某种程度上受到Apache的启发。nginx内存管理的高级描述如下：对于每个连接，动态分配、链接必要的内存缓冲区，用于存储和操作请求和响应的头和主体，然后在连接释放时释放。需要注意的是，nginx尽量避免在内存中复制数据，大多数数据是通过指针值传递的，而不是通过调用memcpy。</p>
<p>再深入一点，当模块生成响应时，将检索到的内容放入内存缓冲区，然后将其添加到buffer chain link。后续处理也与此buffer chain link一起工作。nginx中的缓冲链相当复杂，因为根据模块类型有多种不同的处理方案。例如，在实现body filter模块时，精确地管理缓冲区可能非常困难。这样的模块一次只能对一个缓冲区（链环）进行操作，它必须决定是覆盖输入缓冲区、用新分配的缓冲区替换该缓冲区，还是在该缓冲区之前或之后插入一个新的缓冲区。使事情复杂化的是，有时一个模块将接收多个缓冲区，因此它有一个不完整的缓冲链，必须对其进行操作。然而，目前nginx只提供了一个用于操作缓冲链的低级API，因此在进行任何实际实现之前，第三方模块开发人员应该对nginx的这个神秘部分非常熟悉。</p>
<p>关于上述方法的一个注意事项是，在连接的整个生命周期中都会分配内存缓冲区，因此对于长生存期的连接，会保留一些额外的内存。同时，在空闲的keepalive连接上，nginx只花费550字节的内存。nginx未来版本的一个可能的优化是重用和共享内存缓冲区，用于长时间连接。</p>
<p>管理内存分配的任务由nginx池分配器完成。共享内存区域用于接受互斥体、缓存元数据、SSL会话缓存以及与带宽监控和management (limits) 相关的信息。nginx中实现了一个slab分配器来管理共享内存分配。为了允许同时安全地使用共享内存，可以使用多种锁定机制（互斥锁和信号量）。为了组织复杂的数据结构，nginx还提供了一个红黑树实现。红黑树用于将缓存元数据保存在共享内存中，跟踪 non-regex location definitions以及其他一些任务。</p>
<p>不幸的是，以上所有内容都没有以一致和简单的方式进行描述，这使得为nginx开发第三方扩展的工作变得相当复杂。尽管有一些关于nginx内部构件的好的文档，但是Evan Miller生成的这些文档需要大量的逆向工程工作，而nginx模块的实现对于许多人来说仍然是一门黑色的艺术。</p>
<h2 id="5、经验教训"><a href="#5、经验教训" class="headerlink" title="5、经验教训"></a>5、经验教训</h2><p>当Igor Sysoev开始编写nginx时，大多数支持互联网的软件已经存在，这种软件的架构通常遵循遗留服务器和网络硬件、操作系统和旧的互联网架构的定义。然而，这并不能阻止Igor认为他可以改进web服务器领域的东西。所以，虽然第一课看起来很明显，但事实是：<strong>总有改进的空间</strong>。</p>
<p>出于更好的web软件的想法，Igor花了大量时间开发初始代码结构，并研究了针对各种操作系统优化代码的不同方法。十年后，考虑到多年来在版本1上的积极开发，他正在开发nginx2.0的原型。很明显，新架构的初始原型和初始代码结构对软件产品的未来至关重要。</p>
<p>另一点值得一提的是，发展要有重点。nginx的Windows版本可能是一个很好的例子，说明了如何避免在既不是开发人员的核心能力也不是目标应用程序的东西上稀释开发工作。它同样适用于重写引擎，在多次尝试使用更多特性来增强nginx，以实现与现有遗留设置的向后兼容。</p>
<p>最后，值得一提的是，尽管nginx的开发者社区并不是很大，但nginx的第三方模块和扩展一直是nginx普及的一个非常重要的部分。Evan Miller、Piotr Sikora、Valery Kholodkov、Zhang Yichun（agentzh）和其他有才华的软件工程师所做的工作得到了nginx用户社区及其原始开发人员的高度赞赏。</p>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2020-12-15</p></div> 
    <div class="post-meta__cats"></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/heavyfish.github.io/2020/12/14/Linux/Soft%20limit%20vs%20Hard%20limit/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            no title
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/heavyfish.github.io/2020/12/11/Linux/IO%E6%A8%A1%E5%9E%8B%E5%8F%8Aselect%E3%80%81poll%E3%80%81epoll%E5%92%8Ckqueue%E7%9A%84%E5%8C%BA%E5%88%AB/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            no title
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2021 <a href="/heavyfish.github.io/">速查笔记</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

  



 


    
 

 

 

 

 




    </body>
</html>
