<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/heavyfish.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/heavyfish.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/heavyfish.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/heavyfish.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/heavyfish.github.io/css/main.css">

</script>


<link rel="stylesheet" href="/heavyfish.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heavyfish.github.io","root":"/heavyfish.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="主要介绍了CRI 的整体架构，以及常见的 runtime，以及runc 的原理">
<meta property="og:type" content="article">
<meta property="og:title" content="CRI简介">
<meta property="og:url" content="https://heavyfish.github.io/2020/11/20/k8s/%E4%BB%8B%E7%BB%8DKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%EF%BC%88CRI%EF%BC%89/index.html">
<meta property="og:site_name" content="请问你能包养我吗">
<meta property="og:description" content="主要介绍了CRI 的整体架构，以及常见的 runtime，以及runc 的原理">
<meta property="og:locale">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201120182454155.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/v2-73abb366122482d1050d4863105532e8_1440w.jpg">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/c1dcc33c3ca13f1f07b2a1fdcf8cadc8.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230525843.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/runtimes.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201122234600468.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201122233439802.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230603051.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230614969.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230620576.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230626144.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230632126.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230641228.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230649022.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230656903.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230711783.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230719380.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230727856.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230736191.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230743893.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230753769.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230801038.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230808787.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230815470.png">
<meta property="og:image" content="https://iximiuz.com/implementing-container-runtime-shim/runc-detached-ps-tree.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230824948.png">
<meta property="og:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230836702.png">
<meta property="article:published_time" content="2020-11-20T09:19:06.149Z">
<meta property="article:modified_time" content="2021-01-17T14:38:09.232Z">
<meta property="article:author" content="Shenxr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201120182454155.png">

<link rel="canonical" href="https://heavyfish.github.io/2020/11/20/k8s/%E4%BB%8B%E7%BB%8DKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%EF%BC%88CRI%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>CRI简介 | 请问你能包养我吗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/heavyfish.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">请问你能包养我吗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/heavyfish.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/heavyfish.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/heavyfish.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://heavyfish.github.io/2020/11/20/k8s/%E4%BB%8B%E7%BB%8DKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%EF%BC%88CRI%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/heavyfish.github.io/images/avatar.gif">
      <meta itemprop="name" content="Shenxr">
      <meta itemprop="description" content="在被人包养前，记录学习笔记的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="请问你能包养我吗">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CRI简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-20 17:19:06" itemprop="dateCreated datePublished" datetime="2020-11-20T17:19:06+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-17 22:38:09" itemprop="dateModified" datetime="2021-01-17T22:38:09+08:00">2021-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/heavyfish.github.io/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>主要介绍了CRI 的整体架构，以及常见的 runtime，以及runc 的原理</p>
<a id="more"></a>

<h1 id="1、CRI"><a href="#1、CRI" class="headerlink" title="1、CRI"></a>1、CRI</h1><p><strong>本文翻译于<a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">Introducing Container Runtime Interface (CRI) in Kubernetes</a></strong></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在Kubernetes节点的最底层是一个软件，它可以启动和停止容器。我们称之为“容器运行时/<strong>Container Runtime</strong>”。最广为人知的容器运行时是Docker，但在这个领域它并不是唯一的。事实上，容器运行时领域一直在快速发展。作为使Kubernetes更具可扩展性的一部分，我们一直在为Kubernetes中的容器运行时开发一个新的插件API，称为“CRI”。</p>
<h2 id="什么是CRI？为什么Kubernetes需要它？"><a href="#什么是CRI？为什么Kubernetes需要它？" class="headerlink" title="什么是CRI？为什么Kubernetes需要它？"></a>什么是CRI？为什么Kubernetes需要它？</h2><p>每个容器运行时都有自己的优势，许多用户要求Kubernetes支持更多的<code>runtime</code>。在kubernetes1.5版本中，我们很自豪地引入了<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/242a97307b34076d5d8f5bbeb154fa4d97c9ef1d/docs/devel/container-runtime-interface.md"><strong>Container Runtime Interface（CRI）</strong></a>——一个插件接口，它使kubelet能够使用各种各样的容器运行时，而无需重新编译。CRI包括一个协议缓冲区（ <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/">protocol buffers</a>）和<a target="_blank" rel="noopener" href="http://www.grpc.io/"><strong>grpc api</strong></a>，以及一些正在开发的附加规范和工具的库。CRI在Kubernetes1.5中以Alpha的形式发布。</p>
<p>在Kubernetes中，支持可互换的容器运行时并不是一个新概念。在1.3版本中，我们宣布了rktnetes项目，以启用rkt容器引擎作为Docker容器运行时的替代方案。然而，Docker和rkt都是通过一个内部的 <code>volatile</code> 接口直接和深入地集成到kubelet源代码中的。这样的集成过程需要深入了解Kubelet的内部结构，并且会给Kubernetes社区带来大量的维护开销。这些因素对新生的容器运行时形成了很高的进入壁垒。通过提供一个明确定义的抽象层，我们消除了障碍，并允许开发人员专注于构建他们的容器运行时。这是朝着真正实现可插拔容器运行时和构建更健康的生态系统迈出的一小步，但却是重要的一步。</p>
<h2 id="CRI概览"><a href="#CRI概览" class="headerlink" title="CRI概览"></a>CRI概览</h2><p>Kubelet使用gRPC框架通过Unix套接字与容器运行时（或运行时的CRI-shim）通信，Kubelet充当client，CRI-shim作为server。</p>
<p>![img](<a target="_blank" rel="noopener" href="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/Image">https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/Image</a> 2016-12-19 at 17.13.16-20210114230423672.png)</p>
<p>protocol buffers API包括两个gRPC服务，ImageService和RuntimeService。ImageService提供了从仓库中提取image、检查和删除image的RPC。RuntimeService包含用于管理pod和容器生命周期的rpc，以及与容器交互的调用（exec/attach/port forward）。一个同时管理镜像和容器（例如Docker和rkt）的单一容器运行时可以通过单个套接字同时提供这两种服务。可以通过<code>--container-runtime-endpoint</code>和<code>--image-service-endpoint</code> 在Kubelet中设置套接字。</p>
<p><strong>Pod and container lifecycle management</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service RuntimeService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sandbox operations.</span></span><br><span class="line"></span><br><span class="line">    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) &#123;&#125;  </span><br><span class="line">    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) &#123;&#125;  </span><br><span class="line">    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) &#123;&#125;  </span><br><span class="line">    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) &#123;&#125;  </span><br><span class="line">    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Container operations.  </span></span><br><span class="line">    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) &#123;&#125;  </span><br><span class="line">    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) &#123;&#125;  </span><br><span class="line">    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) &#123;&#125;  </span><br><span class="line">    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) &#123;&#125;  </span><br><span class="line">    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) &#123;&#125;  </span><br><span class="line">    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pod由一组应用程序容器组成，这些容器位于一个有资源限制的隔离环境中。在CRI中，这种环境被称为PodSandbox。我们有意为容器运行时留出一些空间，以根据它们内部的操作方式对PodSandbox进行不同的解释。对于基于hypervisor的运行时，PodSandbox可能表示一个虚拟机。对于其他，比如Docker，它可能是Linux名称空间。PodSandbox必须遵守pod资源规范。在<code>v1alpha1 API</code>中，这是通过启动kubelet创建并传递给运行时的pod级cgroup中的所有进程来实现的。</p>
<p>在启动Pod之前，kubelet call RuntimeService.RunPodSandbox创造环境。这包括为pod设置网络（例如，分配IP）。一旦PodSandbox处于活动状态，就可以独立地创建/启动/停止/删除单个容器。为了删除pod，kubelet将在停止并移除PodSandbox之前停止并移除容器。</p>
<p>Kubelet负责通过RPC管理容器的生命周期，执行容器生命周期挂钩和<code>liveness/readiness</code>检查，同时遵守pod的重启策略。</p>
<h2 id="为什么是一个强制性的以容器为中心的接口"><a href="#为什么是一个强制性的以容器为中心的接口" class="headerlink" title="为什么是一个强制性的以容器为中心的接口?"></a>为什么是一个强制性的以容器为中心的接口?</h2><p>Kubernetes有一个带有Pod resource的声明性API。我们考虑的一个可能的设计是让CRI在其抽象中重用声明性Pod对象，让容器运行时自由地实现和执行自己的控制逻辑，以达到所需的状态。这将大大简化API，并允许CRI使用更广泛的运行时。我们在设计阶段的早期讨论了这种方法，并基于几个原因决定不采用它。首先，kubelet中有许多Pod级特性和特定机制（例如，崩溃循环退避逻辑），这将是所有运行时重新实现的一个重大负担。第二，也是更重要的是，Pod规范过去（现在）仍在快速发展。许多新特性（例如init容器）不需要对底层容器运行时进行任何更改,只需要kubelet直接管理容器。CRI采用了一个命令式容器级接口，这样运行时就可以共享这些共同的特性，从而获得更好的开发速度。这并不意味着我们偏离了“水平触发/level triggered”的哲学——kubelet负责确保实际状态被驱动到声明状态。</p>
<p><strong>Exec/attach/port-forward requests</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service RuntimeService &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ExecSync runs a command in a container synchronously.  </span><br><span class="line">    rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) &#123;&#125;  </span><br><span class="line">    &#x2F;&#x2F; Exec prepares a streaming endpoint to execute a command in the container.  </span><br><span class="line">    rpc Exec(ExecRequest) returns (ExecResponse) &#123;&#125;  </span><br><span class="line">    &#x2F;&#x2F; Attach prepares a streaming endpoint to attach to a running container.  </span><br><span class="line">    rpc Attach(AttachRequest) returns (AttachResponse) &#123;&#125;  </span><br><span class="line">    &#x2F;&#x2F; PortForward prepares a streaming endpoint to forward ports from a PodSandbox.  </span><br><span class="line">    rpc PortForward(PortForwardRequest) returns (PortForwardResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kubernetes提供了一些特性（例如kubectl exec/attach/port forward）供用户与pod和其中的容器进行交互。现在，Kubelet通过调用容器运行时的本地方法调用或使用节点上可用的工具（例如nsenter和socat）来支持这些特性。在节点上使用工具不是一个可移植的解决方案，因为大多数工具都假设pod是使用Linux名称空间隔离的。在CRI中，我们在API中显式地定义这些调用，以允许特定于运行时的实现。</p>
<p>目前kubelet实现的另一个潜在问题是kubelet处理所有 数据流请求的连接，因此它可能成为节点上网络流量的瓶颈。在设计CRI时，我们结合了这个反馈，以允许运行时消除中间件。容器运行时可以根据请求启动一个单独的<code>streaming server</code>（并且可以潜在地将资源使用情况计入pod！），并将服务器的位置返回给kubelet。然后Kubelet将这些信息返回给Kubernetes API server ，后者直接打开到运行时提供的服务器的流连接，并将其连接到客户端。</p>
<p>CRI还有许多其他方面没有在这篇博文中涉及。详情请参阅<a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md#design-docs-and-proposals">设计文件及建议书</a>一览表</p>
<h2 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a>当前状态</h2><p>尽管CRI仍处于早期阶段，但已经有几个项目正在开发中，以使用CRI集成容器运行时。以下是几个例子：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cri-o.io/">cri-o</a>: 符合OCI的运行时</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes-incubator/rktlet">rktlet</a>: rkt容器运行时</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/frakti">frakti</a>: 基于hypervisor的容器运行时</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/tree/release-1.5/pkg/kubelet/dockershim">docker CRI shim</a>.</li>
</ul>
<h1 id="2、概念解释"><a href="#2、概念解释" class="headerlink" title="2、概念解释"></a>2、概念解释</h1><p>docker、containered，runc，CRI，cri-o，docker CRI shim，shim，docker-init，docker-proxy</p>
<h2 id="OCI"><a href="#OCI" class="headerlink" title="OCI"></a>OCI</h2><p>开放容器计划（<strong>Open Container Initiative</strong>）是一个开放治理结构，其明确目的是围绕容器格式和运行时创建开放行业标准。</p>
<p>OCI由Docker和其他容器行业的领导者于2015年6月建立，目前包含两个规范：运行时规范（runtime-spec）和镜像规范（image-spec）。运行时规范概述了如何运行在解压到磁盘上的“<code>文件系统包/filesystem bundle</code>”。在较高级别上，OCI实现将下载OCI镜像，然后将该镜像解压缩为OCI Runtime filesystem bundle。此时，OCI Runtime filesystem bundle将由OCI运行时运行。</p>
<p>详情参见：</p>
<p><a target="_blank" rel="noopener" href="https://opencontainers.org/">OCI官网</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanjingnan/p/6474272.html">OCI(Open Container Initiative) &amp; OCF (Open Container Format)-博客园</a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>在1.11版本之前，Docker的实现是一个单片守护进程。monolith将所有事情都作为一个包来完成，比如下载容器映像、启动容器进程、暴露远程API、充当日志收集守护进程，所有这些都在一个以root用户身份运行的集中进程中。</p>
<p>这种集中式体系结构在部署方面有一些好处，但也暴露出其他一些基本问题。例如，它没有遵循Unix进程和权限分离的最佳实践。此外，这种单片实现使得Docker很难与Linux init systems正确集成，如 upstart和systemd 等。</p>
<p>当Docker1.11发布时，这导致了Docker被分成了不同的部分，如下面开头的段落所述。</p>
<blockquote>
<p>“我们很高兴推出DockerEngine1.11，这是我们基于<em>runC</em> 和 <em>containerd</em> 的第一个版本。Docker也是第一个发布基于OCI技术的runtime。</p>
</blockquote>
<p>有关OCI的信息参见其<a target="_blank" rel="noopener" href="https://www.opencontainers.org/">官网</a>。</p>
<p>下图展示了Docker1.11在runC 和 containerd 上构建的新架构：</p>
<img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201120182454155.png" alt="image-20201120182454155" style="zoom:50%;" />

<p>自此，containerd现在处理容器的执行，这以前是由docker守护进程自己完成的。如下是确切的流程：</p>
<ol>
<li>用户从Docker CLI运行命令</li>
<li>Docker CLI与Docker daemon（dockerd）对话</li>
<li>Docker daemon（dockerd）监听请求并通过containerd管理容器的生命周期</li>
<li>containerd通过runC接收请求并启动一个容器，并在主机内执行所有的容器生命周期</li>
</ol>
<p>注意：简而言之，<strong>runc</strong>是用于根据OCI规范生成和运行容器的CLI工具。</p>
<p>更具体的细节如下：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/v2-73abb366122482d1050d4863105532e8_1440w.jpg" alt="img"></p>
<ol>
<li>containerd 收到请求后, 并不会自己直接去操作容器, 而是创建一个叫做 containerd-shim 的进程, 让 containerd-shim 去操作容器。</li>
<li>因为容器进程需要一个父进程来做诸如收集状态, 维持 stdin 等 fd 打开等工作. 而假如这个父进程就是 containerd, 那每次 containerd 挂掉或升级, 整个宿主机上所有的容器都得退出了。 而引入了 containerd-shim 就规避了这个问题(containerd 和 shim 并不需要是父子进程关系, 当 containerd 退出或重启时, shim 会 re-parent 到 systemd 这样的 1 号进程上);</li>
<li>我们知道创建容器需要做一些设置 namespaces 和 cgroups, 挂载 root filesystem 等等操作, 而这些事该怎么做已经有了公开的规范了, 那就是 OCI(Open Container Initiative, 开放容器标准). 它的一个参考实现叫做 runc. 于是, containerd-shim 在这一步需要调用 runc 这个命令行工具, 来启动容器;</li>
<li>runc 启动完容器后本身会直接退出, containerd-shim 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程;</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker     ctr</span><br><span class="line">  |         |</span><br><span class="line">  V         V</span><br><span class="line">dockerd -&gt; containerd ---&gt; shim -&gt; runc -&gt; runc init -&gt; process</span><br><span class="line">                      |-- &gt; shim -&gt; runc -&gt; runc init -&gt; process</span><br><span class="line">                      +-- &gt; shim -&gt; runc -&gt; runc init -&gt; process```</span><br></pre></td></tr></table></figure>


<h2 id="Containerd"><a href="#Containerd" class="headerlink" title="Containerd"></a>Containerd</h2><p><a target="_blank" rel="noopener" href="https://github.com/docker/containerd">containerd </a>是容器技术标准化之后的产物，为了能够兼容<a target="_blank" rel="noopener" href="https://www.opencontainers.org/"> OCI 标准</a>，将容器运行时及其管理功能从 Docker Daemon 剥离，形成了containerd。理论上，即使不运行 dockerd，也能够直接通过 containerd 来管理容器。当然，containerd 本身也只是一个守护进程，容器的实际运行时由后面介绍的 runC 控制。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/c1dcc33c3ca13f1f07b2a1fdcf8cadc8.png" alt="img"></p>
<p>containerd 向上为 Docker Daemon 提供了 gRPC 接口，使得 Docker Daemon 屏蔽下面的结构变化，确保原有接口向下兼容。向下通过 containerd-shim 结合 runC，使得引擎可以独立升级，避免之前 Docker Daemon 升级会导致所有容器不可用的问题。</p>
<p>现在，让我们转移我们的注意力，来了解<code>containerd</code>的全部含义。从较高的角度来看，containerd是控制runC的守护程序。在<a target="_blank" rel="noopener" href="https://containerd.io/">containerd</a>官网上，“ containerd管理着其主机系统的整个容器生命周期，从镜像传输和存储到容器执行和监督，再到低级存储再到网络附件等等。</p>
<p>containerd帮助抽象化系统调用或特定于操作系统的功能，以在Linux，Windows或任何其他操作系统上运行容器。它提供了一个client层，任何其他平台（例如Docker或Kubernetes）都可以在该client层上构建，而无需关心内核级别的细节。应该注意的是，在Kubernetes中，containerd可以用作CRI runtime。这些是通过利用containerd获得的：</p>
<ul>
<li>获得 push 和 pull 功能</li>
<li>镜像管理API，用于创建，执行和管理容器及其任务</li>
<li>快照管理。</li>
<li>您将获得所有这些，而不必再为底层的操作系统细节而费解</li>
</ul>
<h2 id="CRI-O"><a href="#CRI-O" class="headerlink" title="CRI-O"></a>CRI-O</h2><p>现在进入CRI-O。在深入研究CRI-O之前，让我们先简要介绍一下CRI pool，即Container Runtime Interface。 CRI是一个插件接口，使kubelet能够使用不同的OCI兼容容器运行时（例如containerd，docker或cri-o），而无需重新编译Kubernetes。如您所知，Kubelet是用于创建Pod和启动容器的集群节点代理</p>
<p>要了解对CRI的需求，明智的是了解Kubernetes在此之前所经历的痛点。 Kubernetes以前绑定到特定的容器运行时，这为上游Kubernetes社区带来了大量维护开销。此外，在Kubernetes上构建解决方案的供应商也经历了相同的开销。这就需要开发CRI，以使Kubernetes容器与各种运行时解耦，从而使其与运行时无关。</p>
<p>由于已经构建了插件，因此CRI-O项目已开始提供专门用于Kubernetes的轻量级运行时。 CRI-O使Kubernetes无需大量工具和代码即可直接运行容器。</p>
<h3 id="CRI-O的组件"><a href="#CRI-O的组件" class="headerlink" title="CRI-O的组件"></a>CRI-O的组件</h3><ul>
<li>OCI兼容的runtime：默认为<code>runC</code>，还支持其他OCI兼容，例如Kata容器。</li>
<li>containers/storage：库用于从仓库中提取镜像。用于管理层和为Pod中的容器创建根文件系统的库。</li>
<li>containers/image：用于从仓库中提取镜像的库。</li>
<li>networking (CNI)：用于为Pod设置网络。 Flannel，Weave和OpenShift-SDN CNI插件已经过测试</li>
<li>container monitoring (conmon)：CRI-O中的实用程序，用于监视容器</li>
<li>Linux的几个核心功能提供了安全性</li>
</ul>
<p>下面的截图说明了整个Kubernetes和CRI-O过程</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230525843.png" alt="image-20210114230525843"></p>
<h2 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h2><p>OCI 定义了容器运行时标准，runC 是 Docker 按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。</p>
<p>runC 是从 Docker 的 libcontainer 中迁移而来的，实现了容器启停、资源隔离等功能。RunC 作为容器的runtime，不包含镜像的管理，如果直接使用，需要先准备好镜像</p>
<h2 id="OCI-Bundle"><a href="#OCI-Bundle" class="headerlink" title="OCI Bundle"></a>OCI Bundle</h2><p>OCI Bundle 是指满足 OCI 标准的一系列文件，这些文件包含了运行容器所需要的所有数据，它们存放在一个共同的目录，该目录包含以下两项：</p>
<ul>
<li><code>config.json</code> 包含容器运行的配置数据；</li>
<li>容器的 root filesystem 。</li>
</ul>
<p>如果主机上安装了 Docker，那么可以使用 <code>docker export</code> 命令将已有镜像导出为 OCI Bundle 的格式。</p>
<h2 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h2><p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/runtimes.png" alt="img"></p>
<img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201122234600468.png" alt="image-20201122234600468" style="zoom:50%;" />

<p>container runtime 分为了 low-level 和 high-level</p>
<img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20201122233439802.png" alt="image-20201122233439802" style="zoom:50%;" />

<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230603051.png" alt="image-20210114230603051"></p>
<blockquote>
<p>目前最好的配置是containerD + runc。但Dockershim+runc 是多数环境的默认配置。</p>
</blockquote>
<h2 id="Kubernetes-中-runtime-一览"><a href="#Kubernetes-中-runtime-一览" class="headerlink" title="Kubernetes 中 runtime 一览"></a>Kubernetes 中 runtime 一览</h2><p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230614969.png" alt="image-20210114230614969"></p>
<p>docker-shim 作为一个实现了CRI 接口的gRPC服务器，供 kubelet 使用。这样的过程其实就是，kubelet作为客户端 通过gRPC调用dockershim服务器，dockershim 内部又通过docker客户端走 http 调用 docker daemon api，多走了一次通讯的开销。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230620576.png" alt="image-20210114230620576"></p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230626144.png" alt="image-20210114230626144"></p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230632126.png" alt="image-20210114230632126"></p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230641228.png" alt="image-20210114230641228"></p>
<h2 id="本节参考文档"><a href="#本节参考文档" class="headerlink" title="本节参考文档"></a>本节参考文档</h2><p><a target="_blank" rel="noopener" href="https://opencontainers.org/">OCI官网</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanjingnan/p/6474272.html">OCI(Open Container Initiative) &amp; OCF (Open Container Format)-博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://computingforgeeks.com/docker-vs-cri-o-vs-containerd/">Docker vs CRI-O vs Containerd</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2017/02/Docker-Containerd-RunC">Docker、Containerd、RunC…：你应该知道的所有</a></p>
<p><a target="_blank" rel="noopener" href="https://gohalo.me/post/docker-component-runc-introduce.html">Docker RunC 简介</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87602649">kubelet之cri演变史</a>——重要</p>
<p><a target="_blank" rel="noopener" href="https://xuxinkun.github.io/2017/12/12/docker-oci-runc-and-kubernetes/">docker、oci、runc以及kubernetes梳理</a></p>
<p><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fevents19.linuxfoundation.org%2Fwp-content%2Fuploads%2F2017%2F11%2FHow-Container-Runtime-Matters-in-Kubernetes_-OSS-Kunal-Kushwaha.pdf">How Container Runtimes matter in Kubernetes?</a>——重要</p>
<p><a target="_blank" rel="noopener" href="https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r">Container Runtimes Part 1: An Introduction to Container Runtimes</a>——重要</p>
<h1 id="3、CRI-O"><a href="#3、CRI-O" class="headerlink" title="3、CRI-O"></a>3、CRI-O</h1><h2 id="CRI-O是什么"><a href="#CRI-O是什么" class="headerlink" title="CRI-O是什么"></a>CRI-O是什么</h2><p>CRI-O 这个名字来源于CRI plus Open Container Initiative（OCI），因为CRI-O严格关注符合OCI的 runtime 和 container images。</p>
<p>CRI-O是kubernetescri（容器运行时接口）的一个实现，可以使用与OCI（opencontainer Initiative）兼容的运行时。它是使用Docker作为kubernetes运行时的轻量级替代方案。它允许Kubernetes使用任何符合OCI的运行时作为运行pod的容器运行时。今天，它支持runc和Kata容器作为容器运行时，但是任何符合OCI的运行时原则上都可以插入。</p>
<p>今天，CRI-O支持runc和Clear Container runtimes。它可以从任何容器仓库中提取镜像，并使用容器网络接口（<a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">CNI</a>）处理网络，这样任何与CNI兼容的网络插件都可能与此项目一起工作。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>当Kubernetes需要运行一个容器时，它与CRI-O对话，CRI-O守护进程与runc（或其他符合OCI的运行时）一起启动容器。当Kubernetes需要停止容器时，CRI-O处理这个问题。没有什么特别的，它只是在幕后管理Linux容器，这样用户就不必担心容器编排的这一关键部分。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230649022.png" alt="image-20210114230649022"></p>
<p>让我们看下更细致的架构：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230656903.png" alt="image-20210114230656903"></p>
<p>架构中的组件如下：</p>
<ul>
<li>Kubernetes 联系 kubelet 启动一个 pod.<ul>
<li>Pods是一个kubernetes概念，由一个或多个容器组成，这些容器共享相同的IPC、NET和PID名称空间，并位于同一个cgroup中.</li>
</ul>
</li>
<li>kubelet 转发请求给 CRI-O daemon 通过 kubernetes CRI (Container runtime interface) 以启动一个新 POD.</li>
<li>CRI-O 使用 <code>containers/image</code> library 从镜像仓库拉取镜像.</li>
<li>下载好的镜像被解压到 container’s root filesystems, 存储到 COW file systems, 使用 containers/storage library 操作。</li>
<li>在为容器创建rootfs之后，CRI-O生成一个OCI运行时规范json文件，描述如何使用OCI Generate工具运行容器</li>
<li>然后，CRI-O使用该json规范启动一个与OCI兼容的运行时来运行容器进程。默认的OCI运行时是runc.</li>
<li>每个容器都由一个单独的<code>conmon</code>进程监视。<code>conmon</code>进程持有容器进程的PID1的pty。它处理容器的日志记录并记录容器进程的退出代码.</li>
<li>pod的网络是通过使用<a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">CNI</a>设置的，因此任何CNI插件都可以与CRI-O一起使用.</li>
</ul>
<h2 id="CRI-O-不是什么"><a href="#CRI-O-不是什么" class="headerlink" title="CRI-O 不是什么"></a>CRI-O 不是什么</h2><p>CRI-O的范围是与Kubernetes合作，管理和运行OCI容器。它并不是一个面向开发人员的工具，尽管该项目确实有一些面向用户的工具用于故障排除。</p>
<p>例如，构建镜像超出了CRI-O的范围，这就留给了Docker的build命令、<a target="_blank" rel="noopener" href="https://github.com/projectatomic/buildah">Buildah</a>或<a target="_blank" rel="noopener" href="https://github.com/openshift/source-to-image">OpenShift的Source-to-Image</a>（S2I）之类的工具了。</p>
<p>虽然CRI-O确实包含命令行接口（CLI），但它主要用于测试CRI-O，而不是作为在生产环境中管理容器的方法</p>
<h2 id="本节参考文档-1"><a href="#本节参考文档-1" class="headerlink" title="本节参考文档"></a>本节参考文档</h2><p><a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/introducing-cri-o-10">Introducing CRI-O 1.0</a></p>
<p><a target="_blank" rel="noopener" href="https://cri-o.io/">https://cri-o.io/</a></p>
<h1 id="从容器化到编排"><a href="#从容器化到编排" class="headerlink" title="从容器化到编排"></a>从容器化到编排</h1><p>本文翻译于<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#runtime-shims">A journey from containerization to orchestration and beyond</a></p>
<p>容器催生了更高级的服务器端架构和复杂的部署技术。容器现在是如此广泛，以至于已经有一堆标准的类似规范（<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runtime-spec">1</a>，<a target="_blank" rel="noopener" href="https://github.com/opencontainers/image-spec">2</a>，<a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">3</a>，<a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">4</a>，…）来描述容器的不同方面。当然，最底层的是Linux原语，比如<em>namespaces</em>和<em>cgroup</em>。但是容器化软件已经非常庞大，如果没有它自己的关注点分离层，几乎不可能实现它。在这项持续的努力中，我试图实现的目标是引导自己从最底层开始到最高层，尽可能多地练习（代码、安装、配置、集成等），当然，也要尽可能的有趣。这个页面的内容会随着时间的推移而变化，反映出我对这个主题的理解。</p>
<h2 id="Container-Runtimes"><a href="#Container-Runtimes" class="headerlink" title="Container Runtimes"></a>Container Runtimes</h2><p>我想从最底层的非内核原语——<strong>container runtime</strong>开始这段旅程。在容器中，runtime这个词有点不明确。每个项目、公司或社区对“container runtime”这一术语有自己的、通常是上下文相关的理解。大多数情况下，运行时的特点是由一组职责定义，从最基本的（创建命名空间、启动init进程）到全面的容器管理（包括（但不限于）镜像操作）。<a target="_blank" rel="noopener" href="https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r">本文</a>对运行时有一个很好的概述。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230711783.png" alt="image-20210114230711783"></p>
<p>本节专门介绍<em>low-level container runtimes</em>。一群大玩家组成了一个开放容器计划（<a target="_blank" rel="noopener" href="https://www.opencontainers.org/">OCI</a>），在<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runtime-spec">OCI运行时规范</a>中对底层运行时进行了标准化。简单地说：低级容器运行时是一种软件，它将包含rootfs的文件夹和描述容器参数（如资源限制、装入点、要启动的进程等）的配置[文件]作为输入，结果运行时启动一个孤立的进程，即容器。</p>
<p>截至2019年，使用最广泛的容器运行时是<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">runc</a>。这个项目开始时是Docker的一部分（因此它是用Go编写的），但最终被提取并转换为一个自给自足的CLI工具。runc基本上是OCI运行时规范的参考实现。在我们的旅程中，我们将大量使用runc，这里是一篇<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/implementing-container-runtime-shim/">介绍性文章</a>。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230719380.png" alt="image-20210114230719380"></p>
<p>另一个值得注意的OCI运行时实现是<a target="_blank" rel="noopener" href="https://github.com/containers/crun">crun</a>。它是用C语言编写的，既可以作为可执行文件，也可以用作库。它是由redhat发起的，其他像buildah或podman这样的redhat项目倾向于使用crun而不是runc。</p>
<h2 id="Container-management"><a href="#Container-management" class="headerlink" title="Container management"></a>Container management</h2><p>在命令行中使用runc，我们可以启动任意多个容器。但是如果我们需要自动化这个过程呢？假设我们需要启动数十个容器来跟踪它们的状态。其中一些需要在失败时重新启动，资源需要在终止时释放，镜像必须从仓库中提取，容器间网络需要配置等等。这已经是一个稍微高层次一点的工作了，这是一个<em>container manager</em>的责任。老实说，我不知道这个词是否常用，但我发现用这种方式来组织东西很方便。我将以下项目归类为<em>container managers</em>：<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#containerd">containerd</a>、<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#cri-o">cri-o</a>、<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#dockerd">dockerd</a>和<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#podman">podman</a>。</p>
<h4 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h4><p>与runc一样，我们在这里可以再次看到Docker的遗产——<a target="_blank" rel="noopener" href="https://github.com/containerd/containerd"><em>containerd</em></a>曾经是原始Docker项目的一部分。如今，<em>containerd</em>是另一个独立的软件。它称自己为container runtime，但显然，它与运行时runc不同。不仅<em>containerd</em>和<em>runc</em>的职责不同，而且组织形式也不同。 <em>runc</em>只是一个命令行工具，而containerd是一个长期存在的守护进程。 </p>
<p>Runc的实例不能超过基础容器进程的寿命。通常，它从<code>creat</code>调用开始其生命，然后仅在<code>start</code>时从容器的rootfs <code>exec</code> 指定文件。而 containerd 的寿命 超脱于 基础容器本身。containerd 在一台服务器上，侦听传入的请求以启动，停止或报告容器的状态。并在容器内部使用runc。但是，<em>containerd</em> 不仅仅是容器生命周期管理器。它还负责镜像管理（从仓库中拉取和推入镜像，在本地存储镜像等），跨容器网络管理和其他一些功能。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230727856.png" alt="image-20210114230727856"></p>
<h4 id="cri-o"><a href="#cri-o" class="headerlink" title="cri-o"></a>cri-o</h4><p>另一个 container manager 示例是cri-o。Docker重新架构化衍生了<em>containerd</em>，而cri-o则起源于Kubernetes领域。过去，Kubernetes（ab）使用Docker管理容器。但是，随着rkt的兴起，一些勇敢的人在Kubernetes中增加了对可互换容器运行时的支持，从而允许容器管理由Docker 和/或 rkt完成。但是，这种变化导致在Kubernetes中产生了大量的条件代码，没有人喜欢代码中过多的if。结果，Kubernetes引入了<a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">Container Runtime Interface (CRI)</a>），从而可以在不对Kubernetes端进行任何代码更改的情况下使用任何符合CRI的高级别的运行时（即容器管理器）。 cri-o是Red Hat对CRI兼容运行时的实现。与<em>containerd</em> 一样，<em>cri-o</em> 也是一个守护程序，该守护程序使用 endpoint 暴露 [gRPC] server，以创建，启动，停止（以及许多其他操作）容器。在幕后，cri-o可以使用任何OCI兼容的 [low-level]  运行时来处理容器，但是默认情况下是runc。 cri-o的主要重点是Kubernetes容器运行时。版本控制与k8s版本控制相同，项目范围是明确定义的，并且代码库预计会更小（截至2019年7月，它约为20 CLOC，比<em>containerd</em>的大约少5倍）</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230736191.png" alt="image-20210114230736191"></p>
<p>关于规范的好处是，满足兼容的插件都可以互换使用。一旦引入了CRI，便出现了一个用于<em>containerd</em>的插件，在 <em>containerd</em> 功能的基础上实现CRI gRPC server。这个想法碰巧是可行的，后来<em>containerd</em>本身获得了原生CRI支持。因此，Kubernetes可以同时使用<em>cri-o</em>和 <em>containerd</em>作为运行时。</p>
<h4 id="dockerd"><a href="#dockerd" class="headerlink" title="dockerd"></a>dockerd</h4><p>这里还有一个守护进程是<a target="_blank" rel="noopener" href="https://github.com/moby/moby/tree/master/cmd/dockerd">dockerd</a>。该守护进程是多方面的。一方面，它公开了用于Docker命令行客户端的API，该API为我们提供了所有这些著名的Docker工作流程（<code>docker pull</code>，<code>docker push</code>，<code>docker run</code>，<code>docker stats</code>等）。但是，由于我们已经知道，这一功能已提取到<em>containerd</em>中，所以dockerd在后台依赖<em>containerd</em>就不足为奇了。但这基本上意味着dockerd只是一个前端适配器，其负责将之前使用的 <em>docker engine</em> API  转换为 <em>containerd</em> API 。</p>
<p>但是，dockerd还提供了<code>compose</code> 和 swap，以解决容器编排问题，包括容器的多机器集群。从Kubernetes可以看出，这个问题很难解决。一个dockerd守护程序承担两个重大职责对我来说听起来并不好。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230743893.png" alt="image-20210114230743893"></p>
<h4 id="podman"><a href="#podman" class="headerlink" title="podman"></a>podman</h4><p>这是Red Hat的又一个项目，目的是提供一个名为<code>libpod</code>的库（不是守护程序）来管理镜像，容器生命周期和pod（容器组）。 <code>podman</code>是在此库之上构建的管理命令行工具。作为low-level容器运行时，该项目照常使用runc。从代码的角度来看，podman和cri-o（都是Red Hat项目）之间有很多共同点。例如，他们俩都在内部大量使用出色的<a target="_blank" rel="noopener" href="https://github.com/containers/storage"><em>storage</em></a>和<a target="_blank" rel="noopener" href="https://github.com/containers/image"><em>image</em></a>库。其正努力在cri-o中直接使用libpod而不是runc。 podman的另一个有趣功能是在日常工作流程中直接替换某些docker命令。该项目声称（当然在某种程度上）兼容 Docker CLI API。</p>
<p>当我们已经有了dockerd，container或cir-o时，为什么要启动这样的项目？守护程序作为容器管理器的问题在于，大多数时候必须使用root特权运行守护程序。由于守护程序是一个整体，即使在系统中没有root权限的情况下可以完成90％的守护程序功能，但剩下的10％仍要求以root用户身份启动守护程序。有了podman，最终就有可能利用Linux用户名称空间创建无根容器。这可能是一件大事，尤其是在广泛的CI或多租户环境中，因为即使非特权Docker容器实际上也离获得系统的根访问权限仅一个内核错误。</p>
<h2 id="Runtime-shims"><a href="#Runtime-shims" class="headerlink" title="Runtime shims"></a>Runtime shims</h2><p>容器可能会长时间运行，而由于崩溃，更新或其他一些不可预见的原因，可能需要重新启动容器管理器，而不会杀死（或失去控制）对受管容器。因此，容器的进程必须完全独立于管理者的进程，同时仍保留一些通信方式。如果您尝试自己实现它，您会发现使用runc作为容器运行时会很快变得复杂。以下列出了需要解决的困难</p>
<p><strong>在容器管理器重启时保持容器的stdio流打开</strong></p>
<p>无论管理器的状态如何，我们都需要在任何给定的时间将容器写入的数据转发到其STDOUT和STDERR进行日志记录。出乎意料的是，runc的设计使其成为一项不平凡的任务，因为runc倾向于通过调用者的stdio流传递到容器。因此，使runc进程独立于其父进程几乎是不可能的。如果我们以分离模式启动runc，然后不幸地终止了父进程，则尝试从STDIN读取或写入STDOUT / STDERR的尝试可能导致SIGPIPE杀死该容器。</p>
<p><strong>跟踪容器exit code</strong></p>
<p>OCI运行时规范将容器的启动分为两个步骤。首先，需要 <code>create</code> 容器（即完全初始化），然后再 <code>start</code> 容器。在容器创建步骤中，runc通过 fork 然后退出前台进程来完成容器进程守护。分离容器会导致缺少容器状态更新。解决此问题的一种方法是使启动runc的进程成为<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/dealing-with-processes-termination-in-Linux/#awaiting-a-grandchild-process-termination"><em>subreaper</em></a>。然后，我们可以教它等待容器的进程终止并将其退出代码报告到预定义的位置（例如，磁盘上的文件）。当然，subreaper 进程需要一直存在直到容器进程结束为止</p>
<p><strong>Synchronize container manager and runc container creation</strong></p>
<p>由于runc守护了容器创建进程，因此我们需要一个辅助通道（例如Unix套接字）将容器的实际启动（或失败）传达回容器管理器</p>
<p><strong>Attaching to a running container</strong></p>
<p>我们需要提供一种从容器中传入和传出一些数据的方法，包括PTY控制的方案。听起来我们需要一个侦听服务器来接受附加连接并执行往返于容器stdio的流传输。同样，该 server 必须是长期的。</p>
<p><code>container runtime shim</code>是一个轻量级守护进程，它启动runc并控制容器进程。shim 的进程与容器的进程紧密绑定，但与容器管理器的进程完全分离。容器和管理器之间的所有通信都是通过 shim 进行的</p>
<h2 id="Container-Network-Interface-CNI"><a href="#Container-Network-Interface-CNI" class="headerlink" title="Container Network Interface (CNI)"></a>Container Network Interface (CNI)</h2><p>由于我们有多个具有重叠职责的 container runtimes （或<em>managers</em>），因此很明显，我们需要将与网络相关的代码提取到一个专用项目中，然后再使用它，否则每个运行时都应该有自己的方式来配置NIC设备，路由，防火墙和其他网络方面。例如，cri-o和containerd都必须创建Linux网络名称空间，并设置Linux <code>bridges</code> 和veth设备才能为Kubernetes Pod创建沙箱。为了解决此问题，引入了<a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">the Container Network Interface</a>项目。</p>
<p>CNI项目提供了定义CNI插件的<a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni/blob/master/SPEC.md">Container Network Interface Specification</a>。插件是一个可执行文件[sic]，应该由container runtimes （或<em>managers</em>）调用以建立（或释放）网络资源。插件可用于创建网络接口，管理IP地址分配或对系统进行一些自定义配置。 CNI项目与语言无关，并且由于将插件定义为可执行文件，因此可以在以任何编程语言实现的运行时管理系统中使用。但是，对于最流行的用例，CNI项目还提供了一组参考插件实现，作为独立的存储库（称为<a target="_blank" rel="noopener" href="https://github.com/containernetworking/plugins">插件</a>）提供。例如 <a target="_blank" rel="noopener" href="https://github.com/containernetworking/plugins/tree/master/plugins/main/bridge">bridge</a>, <a target="_blank" rel="noopener" href="https://github.com/containernetworking/plugins/tree/master/plugins/main/loopback">loopback</a>, <a target="_blank" rel="noopener" href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel">flannel</a>, etc.</p>
<p>一些第三方项目将其与网络相关的功能实现为CNI插件。在这里列举一些最著名的:<a target="_blank" rel="noopener" href="https://github.com/projectcalico/cni-plugin">Project Calico</a> and <a target="_blank" rel="noopener" href="https://github.com/weaveworks/weave">Weave</a>.</p>
<h2 id="Orchestration"><a href="#Orchestration" class="headerlink" title="Orchestration"></a>Orchestration</h2><p>容器的编排是一个非常大的主题。Kubernetis解决了现实中最大的问题。</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230753769.png" alt="image-20210114230753769"></p>
<h1 id="Implementing-Container-Runtime-Shim-runc"><a href="#Implementing-Container-Runtime-Shim-runc" class="headerlink" title="Implementing Container Runtime Shim: runc"></a>Implementing Container Runtime Shim: runc</h1><p>本文翻译于<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/implementing-container-runtime-shim/">Implementing Container Runtime Shim: runc</a></p>
<h2 id="What-is-a-shim"><a href="#What-is-a-shim" class="headerlink" title="What is a shim?"></a>What is a shim?</h2><p><a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#runtime-shims">container runtime shim</a>是位于container manager（containerd、cri-o、podman）和container runtime（runc、crun）之间的一个软件，用于解决它们间的集成问题。</p>
<p>找到shim的最简单方法是在运行docker容器的Linux主机上检查进程树：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230801038.png" alt="image-20210114230801038"></p>
<p>一方面，运行时需要shim，以便能够在managers重启动时存活下来。另一方面，shim正在帮助container managers处理rumtime的古怪行为。作为<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/conman-the-container-manager-inception/">container managers实现系列</a>的一部分，我们将尝试创建自己的shim，然后将其与<a target="_blank" rel="noopener" href="https://github.com/iximiuz/conman">conman</a>（一个实验性的container manager）集成。希望在开发过程中，我们能对这个主题有一个深入的了解。</p>
<p>但是，在跳转到shim开发之前，我们需要熟悉所选择的容器运行时组件。<em>conman</em> 使用 <em>runc</em> 作为container runtime。因此，我将从介绍基本的runc用例和它的设计开始这篇文章。然后我将展示从代码中使用runc的简单方法，并解释一些相关的陷阱。本文的最后一部分将概述shim的设计。</p>
<h2 id="使用-runc"><a href="#使用-runc" class="headerlink" title="使用 runc"></a>使用 runc</h2><p>关于什么是容器运行时以及为什么需要容器运行时的详细解释超出了本文的范围。如果您缺乏这方面的知识，请首先<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#container-runtimes">阅读本节</a>，然后查看<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">runc</a> README file，并尝试runc–help</p>
<p>简单地说，runc是一个用于运行容器化应用程序的命令行工具。如果这句话听起来太离奇了，那么可以把runc看作是一个工具，它可以在一个隔离的环境中生成一个新的普通Linux进程。这种隔离包括一个专用的根文件系统和一个新的进程树，它是通过Linux名称空间和cgroups来实现的。我们将这个新进程称为runc启动了一个<strong>container process</strong>。此进程成为新启动的容器中的第一个进程（即PID=1）。在本文的其余部分中，我们将频繁地提到这个进程。</p>
<p>尽管runc最常用于Docker（通过containerd）或cri-o守护进程（而这两个后台进程通常都位于kubelet后面），但它是一个独立的可执行文件，也就是说，runc绝不是一个库。现在让我们尝试在终端模拟器中使用这个工具：</p>
<blockquote>
<p>注意：runc支持运行由<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/linux-pty-what-powers-docker-attach-functionality/">Linux伪终端</a>控制的容器，但是今天我们将不使用这个功能，并将其留给另一篇文章来考虑</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Prepare some directories.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p container1/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> container1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use docker to create a root filesystem <span class="keyword">for</span> our new container.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo bash -c <span class="string">&#x27;docker export $(docker create busybox) | tar -C rootfs -xvf -&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create a default bundle (i.e. container) config.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> runc spec</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Change the default <span class="built_in">command</span> (sh) to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sh -c <span class="string">&#x27;echo Hi, my PID is $$; sleep 10; echo Bye Bye&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&#x27;s/&quot;sh&quot;/&quot;sh&quot;, &quot;-c&quot;, &quot;echo Hi, my PID is $$; sleep 10; echo Bye Bye&quot;/&#x27;</span> config.json</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Do not use pseudoterminal (PTY) to control the container process.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PTY用例不在本文的讨论范围之内.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&#x27;s/&quot;terminal&quot;: true/&quot;terminal&quot;: false/&#x27;</span> config.json</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Review the bundle config (optional).</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> less config.json</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Run the container with ID cont1.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo runc run cont1</span></span><br></pre></td></tr></table></figure>
<p>如果我们在单独的终端会话中使用<code>ps axfo pid,ppid,command</code>检查相应的进程树，我们会看到类似的情况：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230808787.png" alt="image-20210114230808787"></p>
<p>进程层次结构似乎绝对正常。我们的登录bash会话（PID 9503）fork执行runc进程，它反过来 forked 自己（可能是由于<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html">PID命名空间实现相关的原因</a>），第二个fork最终在容器化环境中启动sh shell（PID 22437）</p>
<p>现在，让我们来看看输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, my PID is 1</span><br><span class="line">Bye Bye</span><br></pre></td></tr></table></figure>
<p>注意，即使从主机系统中我们看到sh进程的PID为22437，我们的小脚本打印出来的<code>Hi, my PID is 1</code>。这是它拥有自己的<code>process ID namespace</code>的完美证明。我们还应该关注这样一个事实：容器的stdout内容刚刚打印到我们的终端，这意味着我们登录的bash shell的<em>stdio streams</em>已经被<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/201b06374548b64212f4ceb1529688d435e42899/docs/terminals.md#-pass-through">passed through</a> 到容器，然后被设置为它自己的<em>stdio streams</em>。这是我们需要记住的重要观察。我们可以尝试将进程结构表示如下</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230815470.png" alt="image-20210114230815470"></p>
<p>我们刚刚探讨的运行容器的方法在runc术语中称为<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/201b06374548b64212f4ceb1529688d435e42899/docs/terminals.md#foreground"><strong>foreground</strong></a> 。这意味着runc进程始终处于容器进程和启动进程之间（在我们的示例中是bash shell）。runc支持另一种模式，称为<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/201b06374548b64212f4ceb1529688d435e42899/docs/terminals.md#detached"><strong>detached</strong></a>。让我们试着使用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> from the container1 folder</span></span><br><span class="line">sudo runc run --detach cont1-detached</span><br></pre></td></tr></table></figure>
<p>请注意，runc是如何几乎立即将执行释放回登录shell的。如果我们检查对应的进程树，我们会看到下图：</p>
<p><img src="https://iximiuz.com/implementing-container-runtime-shim/runc-detached-ps-tree.png" alt="img"></p>
<p>似乎runc在生成容器进程之后完全退出了。容器进程被重新分配到主机的PID 1进程。launching process（我们的登录shell）和container process之间没有连接。。。除了passed-through 的 <em>stdio streams</em>！容器进程的输出再次打印到我们的终端，但这次容器产生的行与登录shell提示符交错出现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo runc run --detach cont1-detached</span></span><br><span class="line">Hi, my PID is 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> Bye Bye</span></span><br></pre></td></tr></table></figure>
<p>我们可以尝试将所涉及的进程及其标准流的相应结构描述如下：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230824948.png" alt="image-20210114230824948"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/201b06374548b64212f4ceb1529688d435e42899/docs/terminals.md#detached">runc文档</a>就是这样描述detached模式的：</p>
<blockquote>
<p>与 foreground/前台 模式不同，在 detached/分离 模式下，一旦容器启动，就没有长时间运行的前台runc进程。事实上，根本没有长时间运行的runc进程。但是，这意味着在runc为您设置stdio之后，由调用者来处理它。在shell中（即前台模式下），这意味着在容器设置好之后，runc命令将退出，control 将返回到shell</p>
</blockquote>
<blockquote>
<p>可以通过以下方法之一在分离模式下运行runc：</p>
</blockquote>
<blockquote>
<ul>
<li><code>runc run -d</code> … which operates similar to <code>runc run</code> but is detached.</li>
<li><code>runc create</code>后跟<code>runc start</code>，这是由OCI运行时规范定义的标准容器生命周期（<code>runc create</code>完全设置容器，等待<code>runc start</code>开始执行用户代码）</li>
</ul>
</blockquote>
<blockquote>
<p>detached模式的主要用例是针对希望包装 runc 的高级工具。通过在分离模式下运行runc，这些工具可以在不妨碍runc的情况下更好地控制容器的stdio（大多数围绕runc的包装器，如cri-o或containerd都使用分离模式）</p>
</blockquote>
<blockquote>
<p>不幸的是，与前台模式相比，使用分离模式要复杂一些，并且需要更多的关注——主要是因为现在由调用者来处理容器的stdio</p>
</blockquote>
<p>我们必须承认，前台模式有一些明显的缺点，分离模式的设计是为了消除它们。来自<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/201b06374548b64212f4ceb1529688d435e42899/docs/terminals.md#foreground">同一个文档</a>：</p>
<blockquote>
<p>前台操作模式的主要缺点是它需要长时间运行的前台runc进程。如果您终止前台的runc进程，那么您将无法再访问容器的stdio（在大多数情况下，这将导致容器由于SIGPIPE或其他错误而异常死亡）。扩展来说，这意味着长时间运行的前台runc进程中的任何bug（例如内存泄漏）或错误的OOM-kill 清扫都可能导致容器被杀死，而与用户无关。此外，在前台模式下，无法像stdio（比如–preserve fds）那样直接将文件描述符传递给容器进程。</p>
</blockquote>
<h2 id="通过代码简单使用runc"><a href="#通过代码简单使用runc" class="headerlink" title="通过代码简单使用runc"></a>通过代码简单使用runc</h2><p>略，这里编写了 shell 和 Golang 代码以使用runc 创建容器，验证了 。结论如下：</p>
<p>这个练习表明，如果我们想保持对容器的stdio流的控制，那么<strong>container process</strong>不能独立于 <strong>launching process</strong>。而且我们知道，由于崩溃、更新或其他原因，容器管理器可以重新启动，这使得直接从容器管理器进程启动runc是不可能的。因此，我们需要一个helper进程与底层容器进程的生命周期一样长，并为其提供服务。由此，出现了<strong>container runtime shim</strong></p>
<h2 id="shim的作用"><a href="#shim的作用" class="headerlink" title="shim的作用"></a>shim的作用</h2><p><code>container runtime shim</code>是一个轻量级守护进程，它启动runc并控制容器进程。shim 的进程与容器的进程紧密绑定，但与容器管理器的进程完全分离。容器和管理器之间的所有通信都是通过 shim 进行的。<a target="_blank" rel="noopener" href="https://github.com/containers/conmon">conmon</a>和containerd <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/blob/master/runtime/v2/shim.go"><em>runtime shim</em></a>是一个例子。shim 通常负责以下（可能还有其他一些）事情：</p>
<ul>
<li>即使在 容器管理器 重新启动期间也提供容器的stdout和stderr流。这允许容器管理器在任何给定时刻将容器stdout和stderr转发到日志文件。这是<code>docker logs &lt;container&gt;</code>和<code>kubectl logs &lt;pod&gt; -c &lt;container&gt;</code>命令的功能。当要求容器管理器提供一些容器日志时，它可以直接从磁盘上的预定义位置读取它们。例如，<code>kubectl logs</code> 触发以下调用链：<code>kubectl &lt;-- network --&gt; Kubernetes Core API &lt;-- network --&gt; kubelet &lt;-- (CRI gRPC API) --&gt; CRI Runtime Service (cri-o, containerd, docker) &lt;-- read() --&gt; logs on node&#39;s disk</code>.</li>
<li>连接到正在运行的容器。容器管理器通常提供一些方法来将一些数据 流式地进出容器，包括PTY控制的场景。为此，容器的 shim 需要保证 容器的 stdin 被打开。shim可以建立一个接受连接的socket服务器，并在容器的stdio和连接的client 之间执行流式传输。这保证了 <code>kubectl run -i</code>、<code>podman run -i --tty</code>以及著名的PTY控制的交互式Docker用例（如：<code>docker run -it ubuntu:latest bash</code>）</li>
<li>跟踪 容器 exit code。在分离模式下，runc故意通过 fork 然后退出前台进程来对容器进程进行守护。然后容器进程被重新定义父进程，默认情况下是主机的<em>init</em>进程。分离容器会导致缺少容器状态更新。解决这个问题的一种方法是使 shim 成为一个“<a target="_blank" rel="noopener" href="https://iximiuz.com/en/posts/dealing-with-processes-termination-in-Linux/#awaiting-a-grandchild-process-termination"><em>subreaper</em></a>”。这样，容器进程 将被 reparented 到 shim 。然后，shim 可以等待容器的进程终止，并将其退出代码报告给预定义的目标（例如磁盘上的文件）。相应的容器管理器可以稍后提取它</li>
<li>将容器管理器与容器创建状态同步。由于runc守护 容器创建进程，我们需要一个侧通道（例如Unix套接字）将容器的实际启动（或失败）传回容器管理器。runc通过它的stderr报告容器创建错误。由于稍后完全相同的文件描述符可以成为容器进程的<em>stderr</em>，因此shim 需要小心地使用其中的所有数据，直到 runtime 进程终止，并立即将其报告给容器管理器。因此，如果我们在container命令中输入了一个错误，那么在容器创建阶段会向我们报告实际错误：<code>docker run -it ubuntu bahs docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;bahs\&quot;: executable file not found in $PATH&quot;: unknown</code></li>
</ul>
<h2 id="shim-应用概览"><a href="#shim-应用概览" class="headerlink" title="shim 应用概览"></a>shim 应用概览</h2><p>我们已经知道 container runtime shim  必须是一个与容器进程紧密绑定的长活守护进程。其结构如下图所示：</p>
<p><img src="https://image-1303893285.cos.ap-shanghai.myqcloud.com/image/image-20210114230836702.png" alt="image-20210114230836702"></p>
<p>shim的主进程是短暂的，它的作用是创建一个新的 shim守护进程。它 fork 实际的shim守护进程，将其PID写入磁盘并立即退出，使shim与 launching process 分离（即容器管理器）。长期存在的shim守护进程 首先 创建一个新会话并将其stdio流从父进程分离（通过将它们重定向到/dev/null）。对于任何类似守护进程的软件，这是一些常见的步骤。然后，它又 fork 了另一个进程，即容器进程 的前身。此 进程 执行带有提供的参数（bundle dir，config.json等）的runc create。 shim守护进程等待容器前身的终止，然后将此操作的状态报告回容器管理器。此时，我们只有一个shim守护程序进程和一个分离的容器进程。但是，shim 是容器进程 的 subreaper。最后，shim守护程序进程可以开始为容器的stdio流提供服务，并等待容器终止。知道容器终止状态后，shim 程序会将其写入磁盘上的预定义位置并退出。</p>
<blockquote>
<p>subreaper：A process can define itself as a subreaper with <code>prctl(PR_SET_CHILD_SUBREAPER)</code>。这样可以保证 容器进程的 父进程退出后（即runc ，上面也叫做 容器进程的前身） 被 shim 接管</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/heavyfish.github.io/2020/11/18/Go/The%20Go%20scheduler-v1.8/" rel="prev" title="The Go scheduler-v1.8">
      <i class="fa fa-chevron-left"></i> The Go scheduler-v1.8
    </a></div>
      <div class="post-nav-item">
    <a href="/heavyfish.github.io/2020/11/23/k8s/PLEG%E6%9C%BA%E5%88%B6/" rel="next" title="PLEG机制">
      PLEG机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E3%80%81CRI"><span class="nav-text">1、CRI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCRI%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Kubernetes%E9%9C%80%E8%A6%81%E5%AE%83%EF%BC%9F"><span class="nav-text">什么是CRI？为什么Kubernetes需要它？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRI%E6%A6%82%E8%A7%88"><span class="nav-text">CRI概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%BA%E5%88%B6%E6%80%A7%E7%9A%84%E4%BB%A5%E5%AE%B9%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">为什么是一个强制性的以容器为中心的接口?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="nav-text">当前状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%E3%80%81%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="nav-text">2、概念解释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OCI"><span class="nav-text">OCI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker"><span class="nav-text">Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Containerd"><span class="nav-text">Containerd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRI-O"><span class="nav-text">CRI-O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CRI-O%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-text">CRI-O的组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runc"><span class="nav-text">runc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OCI-Bundle"><span class="nav-text">OCI Bundle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-runtime"><span class="nav-text">Container runtime</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes-%E4%B8%AD-runtime-%E4%B8%80%E8%A7%88"><span class="nav-text">Kubernetes 中 runtime 一览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-text">本节参考文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3%E3%80%81CRI-O"><span class="nav-text">3、CRI-O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CRI-O%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">CRI-O是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-text">架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRI-O-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">CRI-O 不是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-1"><span class="nav-text">本节参考文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%8C%96%E5%88%B0%E7%BC%96%E6%8E%92"><span class="nav-text">从容器化到编排</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-Runtimes"><span class="nav-text">Container Runtimes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-management"><span class="nav-text">Container management</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#containerd"><span class="nav-text">containerd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cri-o"><span class="nav-text">cri-o</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dockerd"><span class="nav-text">dockerd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#podman"><span class="nav-text">podman</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-shims"><span class="nav-text">Runtime shims</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-Network-Interface-CNI"><span class="nav-text">Container Network Interface (CNI)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Orchestration"><span class="nav-text">Orchestration</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implementing-Container-Runtime-Shim-runc"><span class="nav-text">Implementing Container Runtime Shim: runc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-a-shim"><span class="nav-text">What is a shim?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-runc"><span class="nav-text">使用 runc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8runc"><span class="nav-text">通过代码简单使用runc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shim%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">shim的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shim-%E5%BA%94%E7%94%A8%E6%A6%82%E8%A7%88"><span class="nav-text">shim 应用概览</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shenxr"
      src="/heavyfish.github.io/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Shenxr</p>
  <div class="site-description" itemprop="description">在被人包养前，记录学习笔记的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/heavyfish.github.io/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/heavyfish.github.io/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/heavyfish.github.io/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shenxr</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">282k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">4:17</span>
</div>
<!--  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/heavyfish.github.io/lib/anime.min.js"></script>
  <script src="/heavyfish.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/heavyfish.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/heavyfish.github.io/js/utils.js"></script>

<script src="/heavyfish.github.io/js/motion.js"></script>


<script src="/heavyfish.github.io/js/schemes/pisces.js"></script>


<script src="/heavyfish.github.io/js/next-boot.js"></script>


  <script defer src="/heavyfish.github.io/lib/three/three.min.js"></script>
    <script defer src="/heavyfish.github.io/lib/three/canvas_lines.min.js"></script>
    <script defer src="/heavyfish.github.io/lib/three/canvas_sphere.min.js"></script>


  















  

  

<script src="/heavyfish.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/heavyfish.github.io/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":100,"height":250,"hOffset":-7,"vOffset":30},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
